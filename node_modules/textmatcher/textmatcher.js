// textmatcher
import * as assert from "assert";
export function match(...args){
    if(typeof args[0]==="string"){
        const s=args.shift();
        return match(...args)(s);
    }
    return function (s){
        while (args.length>=2) {
            let r=args.shift();
            assert.ok(r && typeof r.exec==="function","not regexp");
            let f=args.shift();
            assert.ok(typeof f==="function", "not function");
            let m=r.exec(s);
            if (m) {
                let a=Array.from(m);          
                return f(m,...a);
            }
        }
        if (args.length==1) {
            let f=args.shift();
            if (typeof f==="function") return f(s);
            return f;
        }
    };
}
export function matcher(str,a){
    let param=(typeof str==="string"?{str}:str);
    str=param.str;
    const m={
        match(reg,f){
            let r=reg.exec(str);
            if(r){
                let n=r.index+r[0].length;
                let rest=str.substring(n);
                let a=Array.from(r);                
                let nm=m.with({str:rest,matched:true},a);
                return nm.with(f(nm,...a));
            }else return m;
        },
        elif(reg,f){
            console.log("elif",m);
            if(m.matched)return m;
            return m.match(reg,f);
        },
        else(f){
            console.log("else",m);
            
            let nm=m.with({matched:false});
            if(m.matched){
                return nm;
            }
            return nm.with(f(nm));
        },
        with(p,a){
            let pp={};
            Object.assign(pp,m);
            Object.assign(pp,p);
            return matcher(pp,a);    
        },
    };
    Object.assign(m,param);
    if(a){
        for(let i=0;i<a.length;i++)m[i]=a[i];
    }
    return m;
}