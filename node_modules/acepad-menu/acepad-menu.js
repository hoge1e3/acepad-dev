
// acepad-menu
/*
import {events} from './events.js';
import {changeSession,sessionInfo} from './sessions.js';
import {getMenuPos,getEditor} from './states.js';
*/
/* global $*/
import {EventHandler} from 'acepad-events';
import isp from "@hoge1e3/is-plain-object";
let sym=Symbol("Menu");
let height=50;
let tabr=50;
export function Menu(editor){
    let container=$(editor.container);
    function add(html,cmd,opt={}){
        if(isp(html)){
            for(let k in html){
                add(k,html[k]);
            }
            return ;
        }
        let pos={};
        let mp=_self.menuPos;
        mp.menuY=mp.menuY||0;
        mp.menuX=mp.menuX||0;
        let h=container.height();
        let m=$("<button>").appendTo(container).addClass("menu");
        if(opt.class)m.addClass(opt.class);
        if(!pos.top&&!pos.bottom){
            pos.bottom=mp.menuY;
            mp.menuY+=height;
            if(mp.menuY>h- height){
                //mp.menuY=0;
                //mp.menuX+=height;
            }
            m.addClass("tab");
        }
        if(!pos.left&&!pos.right){
            pos.right=mp.menuX;
        }
        if(!pos.height){
            pos.height=height;
        }
        let p,lastt;
        const touchstart=(e)=>{
            m.addClass("touched");
            console.log(e.originalEvent);
            const o=e.originalEvent;
            p=o.touches?o.touches[0]:o;
            console.log("st",self.element.innerText,p,JSON.stringify([pos,p]));
            e.preventDefault();
            e.stopPropagation();
            lastt=new Date().getTime();
            self.touchstartPos=p;
            self.fire("touchstart",e);
        };
        const unpx=(s)=>(s+"").replace(/px$/,"")-0;
        const touchmove=(e)=>{
            const o=e.originalEvent;
            let np=(o.touches?o.touches[0]:o);
            if (!p) return;
            let pos={
                bottom:unpx(m.css("bottom")),
                right:unpx(m.css("right")),
                
            };
            console.log("mv",self.element.innerText,JSON.stringify([pos,p,np]));
            let pp={...pos};
            let dy=np.pageY-p.pageY;
            let dx=np.pageX-p.pageX;
            console.log("mv2",dx,dy);
            pos.bottom-=dy;
            pos.right-=dx;
            if(pos.bottom>container.height()-50){
                pos.bottom=pp.bottom;
            }
            if(pos.right>container.width()-50){
                pos.right=pp.right;
            }
            self.fire("move",e);
            m.css(pos);
            self.inOutTab();
            setOrders();
            sort();

            p=np;
            e.preventDefault();
            e.stopPropagation();
        };
        const touchend=(e)=>{
            const o=e.originalEvent;
            let np=(o.touches?o.touches[0]:o);
            m.removeClass("touched");
            if(new Date().getTime()-lastt<300
            &&dist(p,self.touchstartPos)<10){
                self.fire("exec",e);
                cmd(e);
            }else{
                self.fire("endmove",e);
                
            }
            if(m.hasClass("tab")){
                sort();
                m.css({right:0});
            }
            let right=unpx(m.css("right"));
            e.preventDefault();
            e.stopPropagation();
            p=null;
        };
        function dist(p,q){
            let x=p.pageX-q.pageX;
            let y=p.pageY-q.pageY;
            
            return Math.sqrt(x*x+y*y);
        }
        console.log("menucss",html,pos);
        m.css(pos).html(html).
        on("touchstart",touchstart).
        on("touchmove",touchmove).
        on("touchend",touchend).
        on("mousedown",touchstart).
        on("mousemove",touchmove).
        on("mouseup",touchend);
        const isTextOverlapped=()=>{
            let r=rect(self);
            let x=r.left;
            let y=r.top;
            let {row,column}=editor.renderer.pixelToScreenCoordinates(x, y); 
            let {row:row2,column:column2}=
                editor.renderer.pixelToScreenCoordinates(
                x+r.width, y+r.height); 
            let s=editor.session.getLines(row,row2).
            map((s)=>s.substring(column,column2)).
            join("");
            return s.length;
        };
        let ti=setInterval(()=>{
            if(isTextOverlapped()){
                m.css({opacity:"30%"});
            }else m.css({opacity:"100%"});
        },100);
        const self={
            element:m[0],
            isTextOverlapped,
            text:m.text.bind(m),  
            pos(){
                return {
                    bottom:unpx(m.css("bottom")),
                    right:unpx(m.css("right")),
                };
            },
            remove(){
                m.remove();
                clearInterval(ti);
            },
            rect(){
                return rect(self);
            },
            order:0,
            go2nd(){
                self.setOrder(2);
            },
            setOrder(n){
                self.order=n-0.5;
                let a=all().sort((a,b)=>a.order-b.order);
                a.forEach((e,i)=>e.order=i);
                
            },
            inOutTab(){
                let right=self.pos().right;
                if(right<tabr){
                    self.inTab();
                }else{
                    self.outTab();
                }
                
            },
            inTab(){
                if(m.hasClass("tab"))return ;
                m.addClass("tab");
                m.removeClass("float");
            },
            outTab(){
                if(m.hasClass("float"))return ;
                m.addClass("float");
                m.removeClass("tab");
                
            }
        };
        self.element[sym]=self;
        self.go2nd();
        EventHandler.attachTo(self);
        return self;
    }
    function all(selector){
        if(!selector)selector="";
        return [...editor.container.querySelectorAll(
        ".menu"+selector)].
        map(e=>e[sym]);    
    }
    function setOrders(){
        let a=all(".tab").sort((a,b)=>
        a.pos().bottom-b.pos().bottom);
        let i=0;
        for(let e of a){
            e.order=i;
            i++;
        }
    }
    function sort(){
        let a=all(".tab").sort((a,b)=>a.order-b.order);
        let y=0;
        for(let e of a){
            let m=$(e.element);
            if(!m.hasClass("touched")){
                m.css({
                   bottom:y 
                });
            }
            y+=height;
            //console.log(e.rect().height);
        }
    }
    let _self={add,all,menuPos:{},height:50,sort};
    return _self;
}
function rect(m){
    let j=$(m.element);
    let o=j.offset();
    o.width=j.width();
    o.height=j.height();
    return o;
}
