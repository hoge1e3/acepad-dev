import MutablePromise from "mutable-promise";
import {convertStack} from "acepad-convert-stack";
import FS from "@hoge1e3/fs";
import {setMode} from "acepad-mode-shell";

export function trial(f){
    if(typeof f!=="function")return trial(()=>f);
    return (async(...args)=>{
        try{
            await f(...args);
        }catch(e){
             window.onerror(e);       
        }
    });
}
function stripPrompt(line){
    return line.replace(/^.*[:\$%]\s*/,"");
}

//export let dses;
export function debugSession(sh){
    const {
        events,
        getEditor,setConfig,findWord,
        exec,unsetSel,attachCommands,detachCommands,
        setModifier,renderModifierState,
        locate,currentLine,print,goLineEnd,
        sessionInfo,createSession,changeSession,
        findSession,findSessions,
        showMenuButton,showMenuButtons,
    }=sh.$acepad;
    sh.setout({
        log(...a){
            dprint(...a);    
        }
    });
    let dses=createSession({
        type:"debug",
        commands:{
            return(editor){
                onEnter({
                    editor,
                    line:currentLine()
                });
            },
        },
    });
    setMode(dses,{
        sh,
        getContext(editor,session,pos,prefix){
            const line=session.getLine(pos.row);
            let picked=stripPrompt(line);
            let c=pos.column-(line.length-picked.length);
            let secondArg=picked.substring(0, c-prefix.length).match(/\s$/);
            if(secondArg)return "file";
            else return "command";
        }
    });
    let inpmode;
    sh.input=(m)=>inpmode=new MutablePromise();
    if (window.ace_language_tools) {
        let completers=[window.ace_language_tools.textCompleter];
        dses.setOptions({enableLiveAutocompletion:completers});
        //console.log("comp",completers);
    }
    function looksLikeShell(cmd) {
        let res;
        //let head={var:1,let:1,const:1, function:1};
        cmd.replace(/^\s*([\w\-]+)(\s.*)?$/,(_,c,a)=>{
            if(sh.hasCmd(c)){
                res=c+(a||"");
            }
        });
        if(res)return res;
        /* cmd.replace(/^\[(.*)\]\$\s*(.*)/,(_,d,c)=>{
            sh.cd(d);
            res=c;
        });*/
        return res;
    }
    async function onEnter(e){
        const editor=e.editor;
        goLineEnd();
        dprint("\n");
        let issh;
        if(inpmode){
            inpmode.resolve(e.line);
            inpmode=null;
            return ;
        }
        try{
            console.log("one");
            let r;
            issh=looksLikeShell(e.line);
            console.log("two",e.line);
            let f=hasTrace(e.line);
            if(f){
                sh.edit(f.file,f);
                return ;
            }else if (issh) {
                addCommandHist(e.line);
                r=await sh.enterCommand(issh);   
            } else {
                addCommandHist(e.line);
                r=await eval(e.line);
            }
            window.ans=r;
            dprint(r);
            console.log(r);
            dprint("\n");
        }catch(ex){
                print(convertStack(ex.stack||ex+""));
                console.error(ex);
                dprint("\n");
            
        }finally{
            if(issh){
                sh.prompt();
            }
        }
    }
    function cls(){
        dses.setValue("");
        hist();
    }
    sh.cls=cls;
    //dses.setMode("ace/mode/javascript");
    hist();
        //hasTrace=trial(hasTrace);
    function dprint(...a){
        print(dses,...a);
    }
     function hist(){
        for(let k in commandHist){
            dprint(k+"\n");
        }
        for(let i=0;i<10;i++){
            dprint("\n");
        }
    }
    return dses;
}
export var commandHist={};
try{
    commandHist=JSON.parse(
        localStorage.commandHist)||{};
}catch(e){
}
export function addCommandHist(c){
    commandHist[c]=new Date().getTime();
    let s=Object.values(commandHist).sort().reverse();
    let th=s[16]||0;
    for(let k in commandHist){
        if(commandHist[k]<th)delete commandHist[k];
    }
    localStorage.commandHist=
    JSON.stringify(commandHist);
}
export function hasTrace(line){
    let res;
    //const home=getHome();
            console.log("hasTrace",line);
    line.replace(
        /(\/.+):(\d+):(\d+)/,
        (_,f,r,c)=>{
            console.log("hasTrace",f,r,c);
            f=f.replace(/^\/+/,"/");
            f=FS.get(f);
            if(!f.exists()){
                return ;
            }
            res={
                file:f,
                row:r-0,
                column:c-0,
            };
        });
    return res;
}
