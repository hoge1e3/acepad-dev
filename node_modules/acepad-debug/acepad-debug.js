import MutablePromise from "mutable-promise";
import {convertStack,FS} from "acepad-os";

export function trial(f){
    if(typeof f!=="function")return trial(()=>f);
    return (async(...args)=>{
        try{
            await f(...args);
        }catch(e){
             window.onerror(e);       
        }
    });
}

//export let dses;
export function debugSession(sh){
    const {
        events,
        getEditor,setConfig,findWord,
        exec,unsetSel,attachCommands,detachCommands,
        setModifier,renderModifierState,
        locate,currentLine,print,goLineEnd,
        sessionInfo,createSession,changeSession,
        findSession,findSessions,
        showMenuButton,showMenuButtons,
    }=sh.$acepad;
    sh.outUI={
        log(...a){
            dprint(...a);    
        }
    };
    let dses=createSession({
        type:"debug",
        commands:{
            return(editor){
                onEnter({
                    editor,
                    line:currentLine()
                });
            },
        },
    });
    let inpmode;
    sh.input=(m)=>inpmode=new MutablePromise();
    if (window.ace_language_tools) {
        let completers=[window.ace_language_tools.textCompleter];
        dses.setOptions({enableLiveAutocompletion:completers});
        //console.log("comp",completers);
    }
    function looksLikeShell(cmd) {
        let res;
        //let head={var:1,let:1,const:1, function:1};
        cmd.replace(/^\s*([\w\-]+)(\s.+)?$/,(_,c,a)=>{
            if(sh.hasCmd(c)){
                res=c+(a||"");
            }
        });
        if(res)return res;
        cmd.replace(/^\[(.*)\]\$\s*(.*)/,(_,d,c)=>{
            sh.cd(d);
            res=c;
        });
        return res;
    }
    async function onEnter(e){
        const editor=e.editor;
        goLineEnd();
        dprint("\n");
        let issh;
        if(inpmode){
            inpmode.resolve(e.line);
            inpmode=null;
            return ;
        }
        try{
            addCommandHist(e.line);
            let r;
            issh=looksLikeShell(e.line);
            if (issh) {
                r=await sh.enterCommand(issh);   
            } else {
                r=await eval(e.line);
            }
            window.ans=r;
            dprint(r);
            console.log(r);
            dprint("\n");
        }catch(ex){
            let f=hasTrace(e.line);
            if(f){
                sh.edit(f.file,f);
            }else{
                print(convertStack(ex.stack||ex));
                console.error(ex);
                dprint("\n");
            }
        }finally{
            if(issh){
                sh.prompt();
            }
        }
    }
    function cls(){
        dses.setValue("");
        hist();
    }
    sh.cls=cls;
    //dses.setMode("ace/mode/javascript");
    hist();
        //hasTrace=trial(hasTrace);
    function dprint(...a){
        print(dses,...a);
    }
     function hist(){
        for(let k in commandHist){
            dprint(k+"\n");
        }
        for(let i=0;i<10;i++){
            dprint("\n");
        }
    }
    return dses;
}
export var commandHist={};
try{
    commandHist=JSON.parse(
        localStorage.commandHist)||{};
}catch(e){
}
export function addCommandHist(c){
    commandHist[c]=new Date().getTime();
    let s=Object.values(commandHist).sort().reverse();
    let th=s[16]||0;
    for(let k in commandHist){
        if(commandHist[k]<th)delete commandHist[k];
    }
    localStorage.commandHist=
    JSON.stringify(commandHist);
}
export function hasTrace(line){
    let res;
    //const home=getHome();
    line.replace(
        /\((.+):(\d+):(\d+)\)/,
        (_,f,r,c)=>{
            f=FS.get(f);
            if(!f.exists()){
                return ;
            }
            res={
                file:f,
                row:r-0,
                column:c-0,
            };
        });
    return res;
}
