import * as store from "acepad-store";
import {data2file,file2data} from "acepad-store-file";
import {getDelta,getDeltaDelta} from "acepad-sync-delta";
import {FS} from "acepad-os";
import * as assert from "assert";

function getDirInfo(dir){
    return dir.getDirTree({style:"flat-relative",excludes:[".sync/"]});
}
const repof="repo.json";
const treef="tree.json";
const tmpath="/ram/";
function findSync(dir){
    for(let d=dir;d;d=d.up()){
        let s=d.rel(".sync/");
        if(s.exists())return s;
    }
    throw new Error(`.sync not found from ${dir}`);
}
export async function init(name,dir){
    let sync=dir.rel(".sync/");
    if(!sync.exists())sync.mkdir();
    let co=await store.init(name,{});
    const __id__=co.data.__id__;
    sync.rel(repof).obj({
        name,
    });
    sync.rel(treef).obj({
        __id__,
        tree:{},
    });
    return __id__;
}
export async function clone(name,dir){
    if(dir.ls().length)throw new Error("not empty");
    let sync=dir.rel(".sync/");    
    sync.mkdir();
    let co=await store.checkout(name);
    const __id__=co.data.__id__;
    let zip=await data2zip(co.data);
    await FS.zip.unzip(zip,dir);
    sync.rel(repof).obj({
        name,
    });
    sync.rel(treef).obj({
        __id__,
        tree:getDirInfo(dir),
    });
    return __id__;
}
function updateTree(dir){
    let sync=findSync(dir);
    let lcltree=getDirInfo(sync.up());
    let t=sync.rel(treef).obj();
    t.tree=lcltree;
    sync.rel(treef).obj(t);
}
async function data2zip(data,unzip){
    if(!data.__id__){
        console.log("data",data);
        throw new Error("no __id__");
    }
    let ram=FS.get(tmpath);    
    let zip=ram.rel(data.__id__+".zip");
    data2file(data,zip);
    if(!unzip)return zip;
    let ext=ram.rel(data.__id__+"/");
    await FS.zip.unzip(zip,ext,{overwrite:true});
    return ext;
}
async function data2tree(data){
    let ext=await data2zip(data,true);
    let tree=getDirInfo(ext);
    console.log("data2tree", tree);
    if (!tree) {
        console.log("data", data);
        console.log("ext", ext.path());
        throw new Error("No tree");
    }
    return {dir: ext, tree};
}
function getInfo(dir){
    let sync=findSync(dir);
    dir=sync.up();
    let {name}=sync.rel(repof).obj();
    let trdata=sync.rel(treef).obj();
    let lcltree1=trdata.tree;
    return {
        dir,
        sync,
        name,
        trdata,//local of prev sync
        lcltree1,
        get_lcltree2(){//local of current
            this.lcltree2=this.lcltree2||getDirInfo(dir);
            return this.lcltree2;
        },
        async get_rmtco(){
            this.rmtco=this.rmtco||await store.checkout(name);
            return this.rmtco;
        }
    };
}
export async function checkout(_dir){
    /*
    let sync=findSync(dir);
    dir=sync.up();
    let {name}=sync.rel(repof).obj();
    let trdata=sync.rel(treef).obj();
    let lcltree1=trdata.tree;
    let rmtco=await store.checkout(name);
    */
    let info=getInfo(_dir);
    let {dir,sync,trdata,lcltree1}=info;
    let rmtco=await info.get_rmtco();
    if (rmtco.data.__id__===trdata.__id__){
        return "up2date";
    }
    let {tree:rmtree,dir:rmtdir}=await data2tree(rmtco.data);
    assert.ok(rmtree,"rmtree");
    console.log("rmtree",rmtree, "dir",dir);
    let lcltree2=info.get_lcltree2();
    //let lcltree2=getDirInfo(dir);
    console.log("lcltree2",lcltree2);
    let ldelta=getDelta(lcltree1, lcltree2);
    let rdelta=getDelta(lcltree1, rmtree);
    let dd=getDeltaDelta(ldelta,rdelta);
    console.log("remote id",rmtco.data.__id__);
    console.log("dd",dd);
    for (let k in dd.downloads) {
        let d=dd.downloads[k];
        let f=dir.rel(k);//.rm();
        if (d.deleted) {
            console.log("del",f.path());
            f.rm();
        } else {
            console.log("wrt",f.path());
            let r=rmtdir.rel(k);
            r.copyTo(f);
            f.setMetaInfo(r.getMetaInfo());
            
        }
    }
    let cfiles=[], emesg="";
    for (let k in dd.conflicts) {
        let f=dir.rel(k);
        let rmtf=rmtdir.rel(k);
        if(!rmtf.exists())continue;
        if(f.exists()&&rmtf.text()===f.text()){
            continue;
        }
        let cf=conflictFile(f, rmtco.data.__id__);
        emesg+=("Conflict: "+k+"\n");
        emesg+=("Saved to "+cf.name()+"\n");
        rmtf.copyTo(cf);
        cfiles.push({src:f, dst:cf});
    }
    sync.rel(treef).obj({
        __id__:rmtco.data.__id__,
        tree:rmtree,//getDirInfo(dir),
    });
    if (cfiles.length) {
        let e=new Error(emesg);
        e.conflictFiles=cfiles;
        e.__id__=rmtco.data.__id__;
        throw e;
    }
    return rmtco.data.__id__;
}
export async function commit(dir){
    let sync=findSync(dir);
    dir=sync.up();
    let {name}=sync.rel(repof).obj();
    let lcltree1=sync.rel(treef).obj();
    let lcltree2=getDirInfo(dir);
    console.log("lcltree2",lcltree2);
    let ldelta=getDelta(lcltree1.tree, lcltree2);
    if(Object.keys(ldelta).length==0){
        throw new Error("nothing changed.");
    }
    let rmtco=await store.checkout(name);
    if (rmtco.data.__id__!==lcltree1.__id__){
        throw new Error("checkout first.");
    }
    let __id__=lcltree1.__id__;
    let ram=FS.get(tmpath);    
    let zip=ram.rel(__id__+".zip");
    await FS.zip.zip(dir,zip,{excludes:[".sync/"]});
    let data=file2data(zip);
    data.__prev__=__id__;
    
    let nid=await rmtco.commit(data);
    sync.rel(treef).obj({
        __id__:nid.data.__id__,
        tree:getDirInfo(dir),
    });
    return nid.data.__id__;
}
export function conflictFile(f, id) {
    let names=f.name().split(".");
    names[0]+=`(${id.substring(0,8)})`;
    return f.sibling(names.join("."));
}
