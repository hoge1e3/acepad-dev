import * as store from "acepad-store";
import {data2zip,zip2data,data2dir,dir2data,validate} from "acepad-store-file";
import {getDelta,getDeltaDelta} from "acepad-sync-delta";
import {FS} from "acepad-os";
import * as assert from "assert";
import {instance,find,conflictFile} from "acepad-dot-sync";
export async function init(name,dir){
    let co=await store.init(name,{});
    const __id__=co.data.__id__;
    const info=instance(dir);
    info.init({name,__id__});
    return __id__;
}
export async function clone(name,dir){
    if(dir.ls().length)throw new Error("not empty");
    let co=await store.checkout(name);
    const __id__=co.data.__id__;
    let zip=await data2zip(co.data);
    await FS.zip.unzip(zip,dir);
    const info=instance(dir);
    info.init({name,__id__});
    info.updateTree();
    return __id__;
}
const tmpath="/ram/";
/*
async function data2zip(data,unzip){
    if(!data.__id__){
        console.log("data",data);
        throw new Error("no __id__");
    }
    let ram=FS.get(tmpath);    
    let zip=ram.rel(data.__id__+".zip");
    data2file(data,zip);
    if(!unzip)return zip;
    let ext=ram.rel(data.__id__+"/");
    await FS.zip.unzip(zip,ext,{overwrite:true});
    return ext;
}
async function data2tree(data,info){
    let ext=await data2zip(data,true);
    let tree=info.getDirInfo(ext);
    console.log("data2tree", tree);
    if (!tree) {
        console.log("data", data);
        console.log("ext", ext.path());
        throw new Error("No tree");
    }
    return {dir: ext, tree};
}*/

export async function data2tree(data,info){
    let dir=await data2dir(data);
    let tree=info.getDirInfo(dir);
    console.log("data2tree", tree);
    if (!tree) {
        console.log("data", data);
        console.log("ext", dir.path());
        throw new Error("No tree");
    }
    return {dir, tree};
}
async function get_rmtco(info){
    info.rmtco=info.rmtco||await store.checkout(info.name);
    return info.rmtco;
}
export async function checkout(_dir){
    let info=find(_dir);
    let {dir,sync,lcltree1,__id__}=info;
    let rmtco=await get_rmtco(info);
    if (rmtco.data.__id__===__id__){
        return "up2date";
    }
    __id__=rmtco.data.__id__;
    let {tree:rmtree,dir:rmtdir}=await data2tree(rmtco.data,info);
    assert.ok(rmtree,"rmtree");
    console.log("rmtree",rmtree, "dir",dir);
    let lcltree2=info.getLocalTree2();
    console.log("lcltree2",lcltree2);
    let ldelta=getDelta(lcltree1, lcltree2);
    let rdelta=getDelta(lcltree1, rmtree);
    let dd=getDeltaDelta(ldelta,rdelta);
    console.log("remote id",__id__);
    console.log("dd",dd);
    for (let k in dd.downloads) {
        let d=dd.downloads[k];
        let f=dir.rel(k);//.rm();
        if (d.deleted) {
            console.log("del",f.path());
            f.rm();
        } else {
            console.log("wrt",f.path());
            let r=rmtdir.rel(k);
            r.copyTo(f);
            f.setMetaInfo(r.getMetaInfo());
        }
    }
    let cfiles=[], emesg="";
    for (let k in dd.conflicts) {
        let f=dir.rel(k);
        let rmtf=rmtdir.rel(k);
        if(!rmtf.exists())continue;
        if(f.exists()&&rmtf.text()===f.text()){
            continue;
        }
        let cf=conflictFile(f, __id__);
        emesg+=("Conflict: "+k+"\n");
        emesg+=("Saved to "+cf.name()+"\n");
        rmtf.copyTo(cf);
        cfiles.push({src:f, dst:cf});
    }
    info.writeLocal({
        __id__,
        tree:rmtree,//getDirInfo(dir),
    });
    if (cfiles.length) {
        let e=new Error(emesg);
        e.conflictFiles=cfiles;
        e.__id__=__id__;
        throw e;
    }
    return __id__;
}
export async function commit(_dir){
    let info=find(_dir);
    let {dir,sync,__id__,lcltree1,name}=info;
    let lcltree2=info.getLocalTree2();
    
    console.log("lcltree2",lcltree2);
    let ldelta=getDelta(lcltree1, lcltree2);
    if(Object.keys(ldelta).length==0){
        throw new Error("nothing changed.");
    }
    let rmtco=await get_rmtco(info);
    if (rmtco.data.__id__!==__id__){
        throw new Error("checkout first.");
    }
    /*let ram=FS.get(tmpath);    
    let zip=ram.rel(__id__+".zip");
    const excludes=info.getExcludes();
    await FS.zip.zip(dir,zip,{excludes});*/
    let data=await dir2data(dir,{excludes:info.getExcludes()});//zip);
    data.__prev__=__id__;
    validate(data,true);
    let nid=await rmtco.commit(data);
    info.writeLocal({
        __id__:nid.data.__id__,
        tree:info.getLocalTree2(),
    });
    return nid.data.__id__;
}

/*
function getInfo(dir){
    let sync=findSync(dir);
    dir=sync.up();

    let info=createInfo(dir);
    
    const {repof,treef}=info;
    let {name,config}=repof.obj();
    let trdata=treef.obj();
    let lcltree1=trdata.tree;
    let __id__=trdata.__id__;
    return Object.assign(info,{
        name,
        __id__,// local __id__ of prev sync
        lcltree1,//trdata.tree
    });
}
function createInfo(dir){
    const sync=dir.rel(".sync/");
    const repof=sync.rel(repon);
    const treef=sync.rel(treen);
    return {

        repof,treef,
        dir,
        sync,
        getExcludes(){
            return [".sync/",...(
                this.getConfig().excludes||[]
            )];
        },
        getLocalTree2(){//local of current
            return this.getDirInfo();
        },
        getLocalTree1(){//local of last commit
            return this.readLocal().tree;
        },
        updateTree(){
            const lc=this.readLocal();
            lc.tree=this.getLocalTree2();
            this.writeLocal(lc);
        },
        getConfig(){
            let {config}=repof.obj();
            return config||{};
        },
        writeRepo(obj){
            repof.obj(obj);
        },
        writeLocal(obj){
            treef.obj(obj);
        },
        readLocal(obj){
            return treef.obj();
        },
        getDirInfo(_dir){
            _dir=_dir||dir;
            return _dir.getDirTree({
                style:"flat-relative",
                excludes:this.getExcludes()
            });
        },
        init({name,__id__,config}){
            if(!sync.exists())sync.mkdir();
            this.writeRepo({
                name,config,
            });
            const tree={};
            this.writeLocal({
                __id__,
                tree,
            });
        },
    };
}
const repon="repo.json";
const treen="tree.json";

function findSync(dir){
    for(let d=dir;d;d=d.up()){
        let s=d.rel(".sync/");
        if(s.exists())return s;
    }
    throw new Error(`.sync not found from ${dir}`);
}
export function conflictFile(f, id) {
    let names=f.name().split(".");
    names[0]+=`(${id.substring(0,8)})`;
    return f.sibling(names.join("."));
}
*/
//-----
