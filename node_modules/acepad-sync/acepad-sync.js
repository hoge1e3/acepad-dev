import * as store from "acepad-store";
import {data2zip,zip2data,data2dir,dir2data,validate,get as sget} from "acepad-store-file";
import {getDelta,getDeltaDelta} from "acepad-sync-delta";
import FS from "@hoge1e3/fs";
import * as assert from "assert";
import {instance,find,conflictFile} from "acepad-dot-sync";
export async function init(name,dir){
    let co=await store.init(name,{});
    const __id__=co.data.__id__;
    const info=instance(dir);
    info.init({name,__id__});
    return __id__;
}
export async function clone(name,dir){
    if(dir.ls().length)throw new Error("not empty");
    let co=await store.checkout(name);
    const __id__=co.data.__id__;
    let zip=await data2zip(co.data);
    await FS.zip.unzip(zip,dir);
    const info=instance(dir);
    info.init({name,__id__});
    info.updateTree();
    return __id__;
}
export async function checkout(_dir){
    let info=find(_dir);
    let {dir,sync,lcltree1,__id__}=info;
    let rmtco=await get_rmtco(info);
    if (rmtco.data.__id__===__id__){
        return "up2date";
    }
    __id__=rmtco.data.__id__;
    let {tree:rmtree,dir:rmtdir}=await data2tree(rmtco.data,info);
    assert.ok(rmtree,"rmtree");
    console.log("rmtree",rmtree, "dir",dir);
    let lcltree2=info.getLocalTree2();
    //console.log("lcltree2",lcltree2);
    let ldelta=getDelta(lcltree1, lcltree2);
    let rdelta=getDelta(lcltree1, rmtree);
    let dd=getDeltaDelta(ldelta,rdelta);
    console.log("remote id",__id__);
    console.log("dd",dd);
    for (let k in dd.downloads) {
        let d=dd.downloads[k];
        let f=dir.rel(k);//.rm();
        if (d.deleted) {
            console.log("del",f.path());
            f.rm();
        } else {
            console.log("wrt",f.path());
            let r=rmtdir.rel(k);
            r.copyTo(f);
            f.setMetaInfo(r.getMetaInfo());
        }
    }
    let cfiles=[], emesg="";
    for (let k in dd.conflicts) {
        let f=dir.rel(k);
        let rmtf=rmtdir.rel(k);
        if(!rmtf.exists())continue;
        if(f.exists()&&rmtf.text()===f.text()){
            continue;
        }
        let cf=conflictFile(f, __id__);
        emesg+=("Conflict: "+k+"\n");
        emesg+=("Saved to "+cf.name()+"\n");
        rmtf.copyTo(cf);
        cfiles.push({src:f, dst:cf});
    }
    info.writeLocal({
        __id__,
        tree:rmtree,//getDirInfo(dir),
    });
    if (cfiles.length) {
        let e=new Error(emesg);
        e.conflictFiles=cfiles;
        e.__id__=__id__;
        throw e;
    }
    return __id__;
}
export async function commit(_dir){
    let info=find(_dir);
    let {dir,sync,__id__,lcltree1,name}=info;
    let lcltree2=info.getLocalTree2();
    //console.log("lcltree2",lcltree2);
    let ldelta=getDelta(lcltree1, lcltree2);
    if(Object.keys(ldelta).length==0){
        throw new Error("nothing changed.");
    }
    let rmtco=await get_rmtco(info);
    if (rmtco.data.__id__!==__id__){
        throw new Error("checkout first.");
    }
    let data=await dir2data(dir,{excludes:info.getExcludes()});//zip);
    data.__prev__=__id__;
    validate(data,true);
    let nid=await rmtco.commit(data);
    info.writeLocal({
        __id__:nid.data.__id__,
        tree:info.getLocalTree2(),
    });
    return nid.data.__id__;
}
export async function data2tree(data,info){
    let dir=await data2dir(data);
    let tree=info.getDirInfo(dir);
    console.log("data2tree", tree);
    if (!tree) {
        console.log("data", data);
        console.log("ext", dir.path());
        throw new Error("No tree");
    }
    return {dir, tree};
}
async function get_rmtco(info){
    info.rmtco=info.rmtco||await store.checkout(info.name);
    return info.rmtco;
}
export async function download(dir,id){
    await sget(id,dir);
}