// @hoge1e3/dom-mutable-events
type EventOptions = boolean | AddEventListenerOptions;

interface EventData {
  listener: EventListenerOrEventListenerObject;
  options?: EventOptions;
}

const EVENT_DATA = Symbol('event_data');

interface EventfulElement extends Element {
  [EVENT_DATA]?: Map<string, Set<EventData>>;
}

export default class EventManager {
  add(
    target: EventfulElement,
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: EventOptions
  ): void {
    target.addEventListener(type, listener, options);

    if (!target[EVENT_DATA]) {
      target[EVENT_DATA] = new Map();
    }

    const typeMap = target[EVENT_DATA]!;

    if (!typeMap.has(type)) {
      typeMap.set(type, new Set());
    }

    typeMap.get(type)!.add({ listener, options });
  }

  remove(
      target: EventfulElement,
      type?: string,
      listener?: EventListenerOrEventListenerObject,
      options?: EventOptions
    ): void {
      const typeMap = target[EVENT_DATA];
      if (!typeMap) return;
    
      const types = type ? [type] : Array.from(typeMap.keys());
    
      for (const t of types) {
        const eventSet = typeMap.get(t);
        if (!eventSet) continue;
    
        if (listener) {
          for (const event of eventSet) {
            if (
              event.listener === listener &&
              JSON.stringify(event.options) === JSON.stringify(options)
            ) {
              target.removeEventListener(t, event.listener, event.options);
              eventSet.delete(event);
              break;
            }
          }
        } else {
          // リスナー指定なし → すべて削除
          for (const event of eventSet) {
            target.removeEventListener(t, event.listener, event.options);
          }
          eventSet.clear();
        }
    
        if (eventSet.size === 0) {
          typeMap.delete(t);
        }
      }
    
      if (typeMap.size === 0) {
        delete target[EVENT_DATA];
      }
    }


  removeAll(target: EventfulElement): void {
      const typeMap = target[EVENT_DATA];
      if (!typeMap) return;

      for (const [type, eventSet] of typeMap.entries()) {
        for (const { listener, options } of eventSet) {
          target.removeEventListener(type, listener, options);
        }
      }
      delete target[EVENT_DATA];
  }

 delegate(toEl: EventfulElement, fromEl: EventfulElement, type?: string): void {
      const fromMap = fromEl[EVENT_DATA];
      if (!fromMap) return;
    
      const types = type ? [type] : Array.from(fromMap.keys());
    
      for (const t of types) {
        const eventSet = fromMap.get(t);
        if (!eventSet) continue;
    
        for (const { listener, options } of eventSet) {
          fromEl.removeEventListener(t, listener, options);
          toEl.addEventListener(t, listener, options);
    
          if (!toEl[EVENT_DATA]) {
            toEl[EVENT_DATA] = new Map();
          }
    
          const toMap = toEl[EVENT_DATA]!;
          if (!toMap.has(t)) {
            toMap.set(t, new Set());
          }
          toMap.get(t)!.add({ listener, options });
        }
    
        fromMap.delete(t);
      }
    
      if (fromMap.size === 0) {
        delete fromEl[EVENT_DATA];
      }
    }

}
