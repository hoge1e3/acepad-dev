const EVENT_DATA = Symbol('event_data');
export default class EventManager {
    add(target, type, listener, options) {
        target.addEventListener(type, listener, options);
        if (!target[EVENT_DATA]) {
            target[EVENT_DATA] = new Map();
        }
        const typeMap = target[EVENT_DATA];
        if (!typeMap.has(type)) {
            typeMap.set(type, new Set());
        }
        typeMap.get(type).add({ listener, options });
    }
    remove(target, type, listener, options) {
        const typeMap = target[EVENT_DATA];
        if (!typeMap)
            return;
        const types = type ? [type] : Array.from(typeMap.keys());
        for (const t of types) {
            const eventSet = typeMap.get(t);
            if (!eventSet)
                continue;
            if (listener) {
                for (const event of eventSet) {
                    if (event.listener === listener &&
                        JSON.stringify(event.options) === JSON.stringify(options)) {
                        target.removeEventListener(t, event.listener, event.options);
                        eventSet.delete(event);
                        break;
                    }
                }
            }
            else {
                // リスナー指定なし → すべて削除
                for (const event of eventSet) {
                    target.removeEventListener(t, event.listener, event.options);
                }
                eventSet.clear();
            }
            if (eventSet.size === 0) {
                typeMap.delete(t);
            }
        }
        if (typeMap.size === 0) {
            delete target[EVENT_DATA];
        }
    }
    removeAll(target) {
        if (target) {
            const typeMap = target[EVENT_DATA];
            if (!typeMap)
                return;
            for (const [type, eventSet] of typeMap.entries()) {
                for (const { listener, options } of eventSet) {
                    target.removeEventListener(type, listener, options);
                }
            }
            delete target[EVENT_DATA];
        }
        else {
            console.warn('removeAll(): 全要素一括削除はこの構造ではできません。');
        }
    }
    delegate(fromEl, toEl, type) {
        const fromMap = fromEl[EVENT_DATA];
        if (!fromMap)
            return;
        const types = type ? [type] : Array.from(fromMap.keys());
        for (const t of types) {
            const eventSet = fromMap.get(t);
            if (!eventSet)
                continue;
            for (const { listener, options } of eventSet) {
                fromEl.removeEventListener(t, listener, options);
                toEl.addEventListener(t, listener, options);
                if (!toEl[EVENT_DATA]) {
                    toEl[EVENT_DATA] = new Map();
                }
                const toMap = toEl[EVENT_DATA];
                if (!toMap.has(t)) {
                    toMap.set(t, new Set());
                }
                toMap.get(t).add({ listener, options });
            }
            fromMap.delete(t);
        }
        if (fromMap.size === 0) {
            delete fromEl[EVENT_DATA];
        }
    }
}
//# sourceMappingURL=dom-mutable-events.js.map