// @hoge1e3/recursive-safe
export const callPath=Symbol("callPath");
export const visited=Symbol("visited");
function isPromise(p){
    return p&&typeof p.then==="function";
}
export function Class(defs,opt={}){
    let {argKey,onLoopDetected}=opt;
    argKey=argKey||defs.argKey||
    (({args})=>args[0]);
    onLoopDetected=onLoopDetected||defs.onLoopDetected||
    function (){
        const buf=this[callPath];
        console.log(buf);
        throw Object.assign(
            new Error("loop detected"),{callPath:buf});
    };
    class C{
        constructor(){
            this[callPath]=[];
            this[visited]=new Map();
        }
    }
    const p=C.prototype;
    for(let k in defs){
        p[k]=function (...args){
            const key=argKey({
                name:k, args});
            const v=this[visited];
            const path=this[callPath];
            let set=v.get(k);
            if(!set){
                set=new Set();
                v.set(k,set);
            }
            if(set.has(key)){
                return onLoopDetected.call(this,{
                    name:k,
                    trace:path,
                    args});
            }else{
                set.add(key);
                path.push(key);
                const r=defs[k].apply(this,args);
                const pop=(r)=>{
                    set.delete(key);
                    path.pop(key);
                    return r;
                };
                if(isPromise(r)){
                    return r.finally(pop);
                }
                return pop(r);
            }
        };
    }
    return C;
}