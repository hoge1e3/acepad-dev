//#!run
// @hoge1e3/pnode-build
import {file,sibling} from "@acepad/here";

import * as pNode from "petit-node";
//import {test}  from "./test.cjs";
export async function main(dst="built.js"){
  dst=this.resolve(dst);
  const home=this.resolve(".");
  const mp=home.rel("package.json").obj().main;
  const target=home.rel(mp).path();
  return build(target,dst);
}

function map2jsonObject(m) {
  const obj = {};
  for (const [k, v] of m) {
    obj[k] = v instanceof Map ? map2jsonObject(v) : v;
  }
  return obj;
}export async function build(target,dst){
  //try{
  const a=pNode.loadedModules();
  let mod=await compile(target);
  /*}catch(e){
    console.error(e.original)
  }*/
  console.log("pn",a.getByPath("petit-node"));
  if (!mod) {
    throw new Error(`module for ${target} not found`);
  }
  let mods=[];
  let m2id=new WeakMap();
  //id=number
  function getId(mod) {
    if(m2id.has(mod))return m2id.get(mod);
    for (const d of mod.dependencies) {
      getId(d);
    }
    m2id.set(mod,mods.length);
    mods.push(mod);
  }
  function map2json(m) {
    const obj = {};
    for (const [k, v] of m) {
      obj[k] = getId(v);
    }
    return JSON.stringify(obj);//, null, 2);
  }

  getId(mod);
  const Re="cheediwh"+"sifeudi";
  const Di="jejf"+"ksjfi";
  let buf="";
  const q=(d)=>d instanceof Map?
  map2json(d):JSON.stringify(d);
  const idc=(m)=>`/*${getId(m)}*/`;
  for(let m of mods){
    if(m.type==="Builtin"){
      buf+=`${idc(m)}b(${q(m.path)});\n`;
    }else if(m.type==="ES"){
      let rep=m.generatedCode;
      for(let d of m.dependencies){
        if(!d.url){
          //addURL(d);
          //console.log(d);
          throw new Error(`${d.path}(from ${m.path}) no url`);
        }
        rep=replaceAll(rep,d.url,
          Re+Di+m2id.get(d)+Re);
      }
      /*rep=rep.replace(/\bimport\s*\.\s*meta\s*\.\s*url\b/g,
      q(m.path));*/
      const sa=rep.split(Re).map((s)=>
        s.startsWith(Di)?
          s.substring(Di.length)-0:s);
      const ts=file(m.path).lastUpdate();
      buf+=`${idc(m)}es(${q(m.path)},${ts},${q(sa)});\n`;
      console.log(m2id.get(m),m.path, sa);
    }else if(m.type==="CJS"){
      console.log(m);
      const ts=file(m.path).lastUpdate();
      buf+=`${idc(m)}cjs(${q(m.path)},${ts},${q(m.dependencyMap)},function(require, exports, module, __filename, __dirname ){
${m.generatedCode}
});\n`;
    }
    //console.log(m2id.get(m),m);
  }
  const tmpl=sibling(
    import.meta.url,
    "tmpl.js").text();
  dst.text(
    replaceAll(tmpl,
    "//insert",buf)
  );
}
function replaceAll(s,f, t) {  
  let result = '';
  let i = 0;
  while (true) {
    const j = s.indexOf(f, i);
    if (j === -1) {
      result += s.slice(i);
      break;
    }
    result += s.slice(i, j) + t;
    i = j + f.length;
  }
  return result;
}
async function compile(path) {
  const ent=pNode.resolveEntry("ES", path);
  const compiler=pNode.ESModuleCompiler.create();
  const compiled=await compiler.compile(ent);
  //let u=compiled.url;
  return compiled;
}
function requireArguments(file) {
  const base=file.up();
  const require=this.requireFunc(base);
  const exports={};
  const module={exports};
  const filename=file.path();
  const dirname=base.path();
  return [require, exports, module, filename, dirname ]
  
}
