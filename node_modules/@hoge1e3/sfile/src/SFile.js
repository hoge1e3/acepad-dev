var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SFile_path, _SFile_fs, _SFile_policy;
import { default as Content } from "./Content.js";
import { defaultMIMETYpes } from "./MIMETypes.js";
export { default as Content } from "./Content.js";
export async function getNodeFS() {
    try {
        const fs = await import(/* webpackIgnore: true */ "node:fs");
        const path = await import(/* webpackIgnore: true */ "node:path");
        return new FileSystemFactory({ fs, path, Buffer });
    }
    catch (e) {
        const p = globalThis?.FS;
        if (p && typeof p.getRootFS === "function")
            return p;
        const p2 = globalThis?.pNode?.FS;
        if (p2 && typeof p2.getRootFS === "function")
            return p2;
        throw e;
    }
}
export class FileSystemFactory {
    constructor(deps) {
        this.deps = deps;
        this.mimeTypes = defaultMIMETYpes;
        Content.setBufferPolyfill(deps.Buffer);
    }
    addMIMEType(extension, contentType) {
        this.mimeTypes[extension] = contentType;
    }
    _normalizePath(inputPath) {
        // Normalize path to use forward slashes and resolve to absolute path
        if (inputPath.startsWith("file://")) {
            /*
             Windows:  file:///C:/folder/file.txt  -> C:/folder/file.txt
             Unix/Linux: file:///home/user/file.txt -> /home/user/file.txt
            */
            inputPath = inputPath.substring("file://".length);
            if (inputPath.match(/^\/[a-zA-Z]:/)) {
                inputPath = inputPath.substring(1);
            }
        }
        return (this.deps.path.
            resolve(inputPath).
            replace(/\\/g, "/")
            + (inputPath.match(/[\/\\]$/) ?
                "/" : "")).replace(/\/+/g, "/");
    }
    get(inputPath) {
        //const normalizedPath = this._normalizePath(inputPath);
        return new SFile(this, inputPath); //normalizedPath);
    }
}
function truncSep(path) {
    return path.replace(/[\/\\]+$/, "");
}
function addSep(path) {
    return truncSep(path) + "/";
}
export class Cache {
    constructor(duration = 1000) {
        this.duration = duration;
        this.value = {};
        this.timestamp = 0;
    }
    set(v) {
        this.poke(v);
        this.timestamp = Date.now();
    }
    poke(v) {
        this.value = v;
    }
    get() {
        return this.valid() ? this.value : {};
    }
    valid() {
        return (this.timestamp >= 0 && (this.duration == 0 || Date.now() - this.timestamp < this.duration));
    }
    clear() {
        this.value = {};
    }
    setDuration(d) { this.duration = d; }
}
export class SFile {
    static is(obj) {
        return obj instanceof SFile;
    }
    constructor(__fs, filePath, policy) {
        _SFile_path.set(this, void 0);
        _SFile_fs.set(this, void 0);
        _SFile_policy.set(this, void 0);
        this.cache = new Cache();
        __classPrivateFieldSet(this, _SFile_fs, __fs, "f");
        __classPrivateFieldSet(this, _SFile_path, __fs._normalizePath(filePath), "f");
        __classPrivateFieldSet(this, _SFile_policy, policy, "f");
        if (policy && !policy.topDir.contains(this)) {
            throw new Error(`Cannot create files outside ${policy.topDir}`);
        }
        this._path = __classPrivateFieldGet(this, _SFile_path, "f");
    }
    setPolicy(p) {
        if (__classPrivateFieldGet(this, _SFile_policy, "f"))
            throw new Error("policy already set");
        return new SFile(__classPrivateFieldGet(this, _SFile_fs, "f"), __classPrivateFieldGet(this, _SFile_path, "f"), p);
    }
    clone(_path) {
        const path = _path || __classPrivateFieldGet(this, _SFile_path, "f");
        return new SFile(__classPrivateFieldGet(this, _SFile_fs, "f"), path, __classPrivateFieldGet(this, _SFile_policy, "f"));
    }
    text(str) {
        if (str === undefined) {
            return this.getText();
        }
        return this.setText(str);
    }
    lines() {
        return this.getText().split(/[\r\n]+/);
    }
    getText() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        return fs.readFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), 'utf8');
    }
    setText(str) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        this.prepareDir();
        fs.writeFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), str, 'utf8');
        this.cache.clear();
        return this;
    }
    appendText(str) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        this.prepareDir();
        fs.appendFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), str);
        this.cache.clear();
    }
    getBlob() {
        return new Blob([this.bytes()], { type: this.contentType() });
    }
    async setBlob(blob) {
        return new Promise((succ) => blob.arrayBuffer().then((a) => succ(this.setBytes(a))));
    }
    obj(o) {
        if (o === undefined) {
            return JSON.parse(this.text());
        }
        this.text(JSON.stringify(o, null, 2));
        return this;
    }
    bytes(b) {
        if (b === undefined) {
            return this.getBytes();
        }
        this.setBytes(b);
        return this;
    }
    setBytes(b) {
        const { fs, path, Buffer } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        this.prepareDir();
        if (Content.isArrayBuffer(b)) {
            const bb = Buffer.from(b);
            fs.writeFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), bb);
        }
        else {
            fs.writeFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), b);
        }
        this.cache.clear();
        return b;
    }
    getBytes(options) {
        const { fs, path, Buffer } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        const binType = options?.binType || Buffer;
        const buffer = fs.readFileSync(__classPrivateFieldGet(this, _SFile_path, "f"));
        return binType === ArrayBuffer ? Content.buffer2ArrayBuffer(buffer) : buffer;
    }
    dataURL(url) {
        if (!url) {
            return this.getContent().toURL();
        }
        return this.setContent(Content.url(url));
    }
    stat() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        return fs.statSync(__classPrivateFieldGet(this, _SFile_path, "f"));
    }
    lstat() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        const cached = this.cache.get().lstat;
        if (cached)
            return cached;
        return fs.lstatSync(__classPrivateFieldGet(this, _SFile_path, "f"));
    }
    getMetaInfo({ nofollow } = { nofollow: false }) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        if (nofollow) {
            const lstat = this.lstat();
            return {
                lastUpdate: lstat.mtimeMs,
                link: lstat.isSymbolicLink() ? fs.readlinkSync(__classPrivateFieldGet(this, _SFile_path, "f")) : undefined,
            };
        }
        else {
            const stat = this.stat();
            return {
                lastUpdate: stat.mtimeMs,
                // link is undefined because the link is resolved by statSync
            };
        }
    }
    setMetaInfo(m) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        const stats = this.stat();
        fs.utimesSync(__classPrivateFieldGet(this, _SFile_path, "f"), stats.atime, new Date(m.lastUpdate));
        this.cache.clear();
        return this;
    }
    size() {
        const stats = this.stat();
        return stats.size;
    }
    // File metadata and operations
    lastUpdate() {
        // Spec change: use lstat not stat
        const lstat = this.lstat();
        return lstat.mtimeMs;
    }
    rm(options = {}) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        if (this.isDir({ nofollow: true })) {
            if (options.r || options.recursive) {
                fs.rmSync(__classPrivateFieldGet(this, _SFile_path, "f"), { recursive: true, force: true });
            }
            else {
                fs.rmdirSync(__classPrivateFieldGet(this, _SFile_path, "f"));
            }
        }
        else {
            fs.unlinkSync(__classPrivateFieldGet(this, _SFile_path, "f"));
        }
        this.cache.clear();
        return this;
    }
    exists() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        if (this.cache.get().lstat) {
            return true;
        }
        return fs.existsSync(__classPrivateFieldGet(this, _SFile_path, "f"));
    }
    isDir({ nofollow } = { nofollow: false }) {
        // nofollow: if true and this is a link, returns false.
        if (nofollow) {
            const lstat = this.cache.get().lstat;
            if (lstat)
                return lstat.isDirectory();
        }
        if (!this.exists())
            return false;
        if (nofollow) {
            return this.lstat().isDirectory();
        }
        else {
            // this.stat().isDirectory(); fails if it is missing link
            return this.resolveLink().isDir({ nofollow: true });
        }
    }
    isDirPath() {
        return __classPrivateFieldGet(this, _SFile_path, "f").endsWith("/");
    }
    endsWith(postfix) { return __classPrivateFieldGet(this, _SFile_path, "f").endsWith(postfix); }
    startsWith(prefix) { return __classPrivateFieldGet(this, _SFile_path, "f").startsWith(prefix); }
    // Path and naming methods
    path() {
        return __classPrivateFieldGet(this, _SFile_path, "f");
    }
    equals(s) {
        if (typeof s == "string") {
            return this.path() === s;
        }
        else {
            return this.path() === s.path();
        }
    }
    name() {
        return this.truncSep() + (__classPrivateFieldGet(this, _SFile_path, "f").endsWith("/") ? "/" : "");
    }
    truncSep() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        return path.basename(__classPrivateFieldGet(this, _SFile_path, "f"));
    }
    ext() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        return path.extname(__classPrivateFieldGet(this, _SFile_path, "f"));
    }
    truncExt(e) {
        const name = this.name();
        if (e === undefined) {
            e = this.ext();
        }
        return name.substring(0, name.length - e.length);
    }
    // Relative and navigation methods
    up() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        if (__classPrivateFieldGet(this, _SFile_path, "f") === "/" || __classPrivateFieldGet(this, _SFile_path, "f") === "\\") {
            return null;
        }
        const dirn = path.dirname(__classPrivateFieldGet(this, _SFile_path, "f"));
        if (dirn === __classPrivateFieldGet(this, _SFile_path, "f"))
            return null;
        return this.clone(dirn);
    }
    parent() { return this.up(); }
    sibling(name) {
        const p = this.up();
        if (!p)
            throw new Error(`Cannot get sibling of '/'`);
        return p.rel(name);
    }
    closest(name) {
        if (typeof name === "string") {
            return this.closest((f) => f.rel(name).exists());
        }
        else {
            const f = (f) => {
                const res = name(f);
                if (SFile.is(res))
                    return res;
                if (res)
                    return f;
                return undefined;
            };
            for (let p = this; p; p = p.up()) {
                const r = f(p);
                if (r)
                    return r;
            }
            return undefined;
        }
    }
    relPath(base) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        const body = path.relative(base.path(), __classPrivateFieldGet(this, _SFile_path, "f")).replace(/\\/g, "/");
        return (body + (body.length && this.isDirPath() ? "/" : "")).replace(/\/+$/, "/");
    }
    rel(relPath) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        if (path.isAbsolute(relPath))
            throw new Error(`rel: ${relPath} should be relative`);
        return this.clone(path.join(__classPrivateFieldGet(this, _SFile_path, "f"), relPath));
    }
    _directorify() {
        if (!this.isDirPath())
            __classPrivateFieldSet(this, _SFile_path, __classPrivateFieldGet(this, _SFile_path, "f") + "/", "f");
    }
    // Copy and move methods
    copyFrom(src) {
        return src.copyTo(this);
    }
    toString() { return __classPrivateFieldGet(this, _SFile_path, "f"); }
    /**
     * src.copyTo(dst) is equivalent to cp -r src/* dst/ , not cp -r src dst
     * @param dst
     * @param options
     * @returns
     */
    copyTo(dst, options = { followlink: false }) {
        let src = this;
        const followlink = options.followlink;
        if (followlink) {
            src = src.resolveLink();
            dst = dst.resolveLink();
        }
        const nofollow = !followlink;
        const srcIsDir = src.isDir({ nofollow });
        if (srcIsDir && !dst.exists()) {
            dst.mkdir();
        }
        let dstIsDir = dst.isDir({ nofollow });
        if (!srcIsDir && dstIsDir) {
            dst = dst.rel(src.name());
            dst.assertRegularFile();
            dstIsDir = false;
        }
        if (srcIsDir && !dstIsDir) {
            throw new Error("Cannot move dir " + src.path() + " to file " + dst.path());
        }
        else if (!srcIsDir && !dstIsDir) {
            if (src.isLink())
                src = src.resolveLink();
            if (dst.isLink())
                dst = dst.resolveLink();
            const c = src.getContent();
            dst.setContent(c);
        }
        else {
            if (!srcIsDir || !dstIsDir)
                throw new Error(src + " to " + dst + " should both dirs");
            for (let e of src.listFiles({ cache: 1000 })) {
                e.copyTo(dst.rel(e.relPath(src)), options);
            }
        }
        dst.cache.clear();
        return dst;
    }
    moveFrom(src) {
        return src.moveTo(this);
    }
    moveTo(dst) {
        /*if (dst.exists()) {
          throw new Error(`${dst.path()} already exists`);
        }*/
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        fs.renameSync(__classPrivateFieldGet(this, _SFile_path, "f"), __classPrivateFieldGet(dst, _SFile_path, "f"));
        this.cache.clear();
        /*this.copyTo(dst);
        this.rm({recursive:true});*/
        return dst;
    }
    contentType() {
        return __classPrivateFieldGet(this, _SFile_fs, "f").mimeTypes[this.ext()] || "application/octet-stream";
    }
    isText() {
        return this.contentType().match(/^text\//);
    }
    getContent() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        /*if (this.isText()) {
          const text=fs.readFileSync(this.#path, "utf-8");
          if (Content.looksLikeDataURL(text)) {
            return Content.url(text);
          } else {
            return Content.plainText(text);
          }
        } else {*/
        return Content.bin(fs.readFileSync(__classPrivateFieldGet(this, _SFile_path, "f")), this.contentType());
        //}
    }
    setContent(c) {
        const { fs, path, Buffer } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        this.prepareDir();
        if (c.hasPlainText()) {
            fs.writeFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), c.toPlainText());
        }
        else {
            fs.writeFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), c.toBin(Buffer));
        }
        this.cache.clear();
        return this;
    }
    appendContent(c) {
        const { fs, path, Buffer } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        this.prepareDir();
        if (c.hasPlainText()) {
            fs.appendFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), c.toPlainText());
        }
        else {
            fs.appendFileSync(__classPrivateFieldGet(this, _SFile_path, "f"), c.toBin(Buffer));
        }
        this.cache.clear();
        return this;
    }
    assertDir(options = { nofollow: false }) {
        if (!this.isDir(options)) {
            throw new Error(`${this.path()} is not a directory`);
        }
    }
    assertRegularFile(options = { nofollow: false }) {
        if (this.isDir(options)) {
            throw new Error(`${this.path()} is a directory`);
        }
    }
    // Directory methods
    parseExcludeOption(options = {}) {
        this.assertDir();
        const excludes = options.excludes;
        if (typeof excludes === "function") {
            return { excludesF: excludes };
        }
        else if (typeof excludes === "object") {
            const pathR = this.path();
            let nex = {};
            const cpath = (e) => {
                e = truncSep(e);
                if (e.startsWith("/")) {
                    nex[e] = 1;
                }
                else {
                    nex[pathR + e] = 1;
                }
            };
            if (Array.isArray(excludes)) {
                for (let e of excludes)
                    cpath(e);
            }
            else {
                for (let e in excludes)
                    cpath(e);
            }
            return { excludesF: (f) => nex[truncSep(f.path())] };
        }
        else {
            return { excludesF: () => false };
        }
    }
    each(callback, options) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        this.assertDir();
        const files = fs.readdirSync(__classPrivateFieldGet(this, _SFile_path, "f"));
        const { excludesF } = this.parseExcludeOption(options);
        files.forEach(file => {
            const fileObj = this.rel(file);
            if (!excludesF(fileObj))
                callback(fileObj);
        });
        return this;
    }
    recursive(a1, a2) {
        const options = a2 ?? ((a1 && typeof a1 === "object") ? a1 : {});
        const callback = (a1 && typeof a1 === "function" ? a1 : undefined);
        this.assertDir();
        if (callback) {
            for (let file of this.recursive(options)) {
                callback(file);
            }
            return this;
        }
        else {
            const includeDir = options.includeDir;
            //const {excludesF}=this.parseExcludeOption(options);
            const self = this;
            return {
                *[Symbol.iterator]() {
                    function* walk(dir) {
                        //console.log("walk", dir.path(),includeDir);
                        if (includeDir) {
                            yield dir;
                        }
                        for (const file of dir.listFiles(options)) {
                            if (file.isLink()) {
                                const r = file.resolveLink();
                                const isd = r.isDir({ nofollow: true });
                                if (options.followlink && isd) {
                                    yield* walk(r);
                                }
                                else if (!isd || includeDir)
                                    yield r;
                            }
                            else if (file.isDir({ nofollow: true })) {
                                yield* walk(file);
                            }
                            else {
                                yield file;
                            }
                        }
                    }
                    yield* walk(self);
                }
            };
        }
    }
    getDirTree(_options = {}) {
        let dest = {};
        //const options:GetDirTreeOptions={
        const style = _options.style || "flat-absolute";
        const excludes = _options.excludes || [];
        const base = _options.base || this;
        let excludesFunc;
        if (typeof excludes === "function") {
            excludesFunc = excludes;
        }
        else {
            const excludesAry = (excludes || []).map(truncSep);
            const defaultExcludes = (file) => {
                const fullPath = file.path();
                const relPath = file.relPath(base);
                switch (style) {
                    case "flat-relative":
                    case "hierarchical":
                        if (excludesAry.indexOf(truncSep(relPath)) >= 0) {
                            return true;
                        }
                        break;
                    case "flat-absolute":
                        if (excludesAry.indexOf(truncSep(fullPath)) >= 0) {
                            return true;
                        }
                        break;
                }
                return false;
            };
            excludesFunc = defaultExcludes;
        }
        const newoptions = { style, base, excludes: excludesFunc };
        const files = this.listFiles({ ...newoptions, cache: true });
        if (style == "no-recursive") {
            for (let file of files) {
                dest[file.name()] = file.getMetaInfo({ nofollow: true });
            }
            return dest;
        }
        for (let file of files) {
            const meta = file.getMetaInfo({ nofollow: true });
            if (file.isDir({ nofollow: true })) {
                switch (style) {
                    case "flat-absolute":
                    case "flat-relative":
                        Object.assign(dest, file.getDirTree(newoptions));
                        break;
                    case "hierarchical":
                        dest[addSep(file.name())] = file.getDirTree(newoptions);
                        break;
                }
            }
            else {
                const fullPath = file.path();
                const relPath = file.relPath(base);
                switch (style) {
                    case "flat-absolute":
                        dest[fullPath] = meta;
                        break;
                    case "flat-relative":
                        dest[relPath] = meta;
                        break;
                    case "hierarchical":
                        dest[file.name()] = meta;
                        break;
                }
            }
        }
        return dest;
    }
    /**
     *
     * @param options cache:
     *          If true, the metaInfo(result of .getMetaInfo()) of each file object is cached in the file object.
     *          If false, the metaInfo is retrieved each time from the file system when .getMetaInfo is called.
     *          true is more efficient but the metainfo is NOT changed even if the file is modified by other processes.
     *          If number is specified, the cached info kept within duration in ms
     * @returns
     */
    listFiles(options = { cache: 1000 }) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        const { excludesF } = this.parseExcludeOption(options);
        if (options.cache || options.cache === 0) {
            // cache implicitly sets nofollow: true
            if (!this.isDir({ nofollow: true }) && !this.isLink()) {
                throw new Error(this + ' is not a directory');
            }
            const res = [];
            for (let dirent of fs.readdirSync(__classPrivateFieldGet(this, _SFile_path, "f"), { withFileTypes: true })) {
                const file = this.rel(dirent.name);
                if (excludesF(file))
                    continue;
                const extra = dirent.extra;
                const lstat = (extra && extra.lstat ? extra.lstat : file.lstat());
                file.cache.set({ lstat });
                file.cache.setDuration(typeof options.cache === "boolean" ? 0 : options.cache);
                if (lstat.isDirectory()) {
                    file._directorify();
                }
                res.push(file);
            }
            return res;
        }
        if (!this.isDir()) {
            throw new Error(this + ' is not a directory');
        }
        return fs.readdirSync(__classPrivateFieldGet(this, _SFile_path, "f")).map(file => this.rel(file)).filter(f => !excludesF(f));
    }
    ls(options) {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        //if (!options) return fs.readdirSync(this.#path);
        return this.listFiles(options).map(f => f.fixSep().name());
    }
    fixSep() {
        const lstat = this.lstat();
        if (lstat.isSymbolicLink()) {
            const link = this.resolveLink();
            if (link.isDir()) {
                this._directorify();
            }
        }
        else if (lstat.isDirectory()) {
            this._directorify();
        }
        return this;
    }
    mkdir() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        fs.mkdirSync(__classPrivateFieldGet(this, _SFile_path, "f"), { recursive: true });
        this.cache.clear();
        return this;
    }
    prepareDir() {
        const p = this.up();
        if (!p)
            throw new Error(`Cannot prepare dir for '/'`);
        return p.exists() || p.mkdir();
    }
    contains(file) {
        return truncSep(file.path()).startsWith(truncSep(this.path()));
    }
    isLink() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        if (!this.exists())
            return undefined;
        const stat = fs.lstatSync(__classPrivateFieldGet(this, _SFile_path, "f"));
        if (!stat.isSymbolicLink())
            return undefined;
        return fs.realpathSync(__classPrivateFieldGet(this, _SFile_path, "f"));
    }
    link(to) {
        //to: existent this: non-existent
        //`this` points to `to`
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        fs.symlinkSync(to.path(), __classPrivateFieldGet(this, _SFile_path, "f"), "junction");
        this.cache.clear();
    }
    resolveLink() {
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        return this.clone(fs.realpathSync(__classPrivateFieldGet(this, _SFile_path, "f")));
    }
    watch(_1, _2) {
        let options = {}, listener = function () { };
        if (typeof _1 === "object")
            options = _1;
        if (typeof _2 === "object")
            options = _2;
        if (typeof _1 === "function")
            listener = _1;
        if (typeof _2 === "function")
            listener = _2;
        const { fs, path } = __classPrivateFieldGet(this, _SFile_fs, "f").deps;
        const watcher = fs.watch(__classPrivateFieldGet(this, _SFile_path, "f"), options, (eventType, filename) => {
            const file = filename ? (__classPrivateFieldGet(this, _SFile_fs, "f").deps.path.isAbsolute(filename) ?
                this.clone(filename) :
                this.rel(filename)) : this;
            listener(eventType, file, file.exists() ? file.getMetaInfo() : undefined);
        });
        return {
            remove: () => {
                watcher.close();
            }
        };
    }
}
_SFile_path = new WeakMap(), _SFile_fs = new WeakMap(), _SFile_policy = new WeakMap();
//# sourceMappingURL=SFile.js.map