// @hoge1e3/thread
import MutablePromise from "mutable-promise";
let lastEvt;
setInterval(()=>lastEvt=performance.now(),16);
const sleep=(t)=>new Promise((s)=>globalThis.setTimeout(s,t));


export function run(gen){
    return group.run(gen);
}
export class Group{
    constructor (){
        this.threads=new Set();
        this.stepAllLoop();
        this.queue=[];
    }
    run(gen){
        const t=new Thread(this,gen);
    }
    add(th){
        this.theads.add(th);
        this.resumeStep();
    }
    enqueue(th){
        
    }
    async stepAll(){
        const acts=this.threads.filter(
            (t)=>t.state==active);
        if(!acts.length){
            await this.pauseStep();
            return ;
        }
        for(let t of acts){
            t.step();
            if(performance.now()-
            lastEvt>=16){
                await sleep(0);
            }
        }
    }
    async stepAllLoop(){
        while(true){
            await this.stepAll();
        }
    }
    pauseStep(){
        this.pr=new MutablePromise();
        return this.pr;
    }
    resumeStep(){
        if(this.pr){
            this.pr.resolve();
            this.pr=null;
        }
    }
}
const idle=0;
const active=1;
const running=2;
const terminated=3;
const killed=4;

export function* aw(p){
    const wp=new WrappedPromise(p);
    yield wp;
    if(wp.error){
        throw wp.error;
    }
    return wp.result;
}
export class Thread {
    constructor (group, gen){
        this.gen=gen;
        this.group=group;
        this._state=idle;
        group.add(this);
    }
    get state(){
        return this._state;
    }
    set state(s){
        this._state=s;
        if(s==active)this.group.resumeStep();
    }
    assertState(...states){
        if(!states.includes(this.state)){
            throw new Error(`invalid state ${this.state}, should be either ${states}`);
        }
    }
    step(){
        this.assertState(active,idle);
        this.state=running;
        const {value,done}=this.gen.next();
        if(done){
            this.state=terminated;
            return ;
        }
        if(isWrappedPromise(value)){
            this.waitFor(value);
        }else if(isPromise(value)){
            this.waitFor(new WrappedPromise(value));
        }else if(typeof value==="number"){
            this.waitFor(new WrappedPromise(timeout(value)));
        }else{
            this.state=active;
        }
    }
    waitFor(wp){
        this.assertState(active);
        this.state=idle;
        wp.then((r)=>{
            wp.result=r;
            this.state=active;
        },(e)=>{
            wp.error=e;
            throw e;
        });
    }
}
function isPromise(v){
    return typeof v.then==="function";
}
function isWrappedPromise(v){
    return v instanceof WrappedPromise;
}
class WrappedPromise{
    constructor (p){
        this.promise=p;
    }
}
export const group=new Group();
function timeout(t){
    return new Promise(s=>setTimeout(s,t));
}