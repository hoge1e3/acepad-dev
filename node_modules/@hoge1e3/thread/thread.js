// @hoge1e3/thread

export function run(gen){
    return group.run(gen);
}
export class Group{
    constructor (){
        this.threads=new Set();
    }
    run(gen){
        const t=new Thread(this,gen);
    }
    stepAll(){
        for(let t of this.threads){
            
        }
    }
}
const idle=0;
const active=1;
const running=2;
const terminated=3;
const killed=4;

export function* aw(p){
    const wp=new WrappedPromise(p);
    yield wp;
    if(wp.error){
        throw wp.error;
    }
    return wp.result;
}
export class Thread {
    constructor (group, gen){
        this.gen=gen;
        this.group=group;
        this.state=idle;
        group.threads.add(this);
    }
    assertState(...states){
        if(!states.includes(this.state)){
            throw new Error(`invalid state ${this.state}, should be either ${states}`);
        }
    }
    step(){
        this.assertState(active,idle);
        this.state=running;
        const {value,done}=this.gen.next();
        if(done){
            this.state=terminated;
            return ;
        }
        if(isWrappedPromise(value)){
            this.waitFor(value);
        }else if(isPromise(value)){
            this.waitFor(new WrappedPromise(value));
        }else if(typeof value==="number"){
            this.waitFor(new WrappedPromise(timeout(value)));
        }else{
            this.state=active;
        }
    }
    waitFor(wp){
        this.assertState(active);
        this.state=idle;
        wp.then((r)=>{
            wp.result=r;
            this.state=active;
        },(e)=>{
            wp.error=e;
            throw e;
        });
    }
}
function isPromise(v){
    return typeof v.then==="function";
}
function isWrappedPromise(v){
    return v instanceof WrappedPromise;
}
class WrappedPromise{
    constructor (p){
        this.promise=p;
    }
}
export const group=new Group();
function timeout(t){
    return new Promise(s=>setTimeout(s,t));
}