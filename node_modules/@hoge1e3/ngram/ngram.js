// @hoge1e3/ngram
export const EOF="eof";
export class Document{
    constructor(path,content,timeStamp){
        this.path=path;
        this.timeStamp=timeStamp||Date.now();
        this.content=content;
        this.deleted=false;
    }
    at(offset){
        if(offset==this.content.length)return EOF;
        return this.content[offset];
    }
    toString(){
        return this.path;
    }
}
let thresh=10;
function keyIsDocument(idx){
    return idx.keyType=="doc";
}
function keyIsLetter(idx){
    return idx.keyType=="chr";
}
class RankedList{
    constructor ({rankOf}){
        this.rankOf=rankOf;
        this.byRank=[];
        this.rerank=new Set();
    }
    updateAll(){
        for(let item of this.rerank){
            this.add(item);
        }
        this.rerank=new Set();
    }
    requestUpdate(item){
        if(this.rerank.has(item))return ;
        this.remove(item);
        this.rerank.add(item);
    }
    add(item){
        let r=this.rankOf(item);
        let b=this.byRank;
        b[r]=b[r]||new Set();
        b[r].add(item);
    }
    remove(item){
        let r=this.rankOf(item);
        let b=this.byRank;
        b[r]=b[r]||new Set();
        b[r].delete(item);
    }
    pick(){
        let b=this.byRank;
        for(let i=b.length-1;i>=0;i--){
            if(!b[i]||b[i].size==0){
                b[i]=null;
                if(i==b.length-1)b.length=i;
                continue;
            }
            for(let e of b[i]){
                b[i].delete(e);
                return e;
            }
        }
    }
}
export class DocumentSet{
    constructor (){
        this.root=this.LetterIndex();
        this.rank=new RankedList({
            rankOf(didx){
                let c=1;
                for(let [doc, offsets] of didx.map){
                    c+=offsets.length;
                }
                return Math.floor(Math.log(c));
            }
        });
        this.path2doc=new Map();
    }
    addDocument(doc){
        let old=this.path2doc.get(doc.path);
        if(old){
            old.deleted=true;
        }
        this.path2doc.set(doc.path,doc);
        for(let i=0;i<doc.content.length;i++){
            this.add(this.root,doc,i);
        }
    }
    findIndex(word,lidx=null){
        lidx=lidx||this.root;
        let idx;
        while(word){
            let idx=lidx.get(word[0]);
            if(!lidx)return null;
            if(keyIsDocument(idx))break;
            word=word.substring(1);
        }
        return {index:idx,rest:word};
    }
    *find(word){
        
    }
    async predict(doc,offset){
        
    }
    expand(){
        this.rank.updateAll();
        let didx=this.rank.pick();
        if(!didx)return ;
        return this.toLetterIndex(didx);
    }
    //private
    LetterIndex(){
        let lidx=new Index("chr");
        return lidx;
    }
    DocumentIndex(){
        let didx=new Index("doc");
        return didx;
    }
    addChr(map,doc,offset){
        let ch=doc.at(offset);
        if(ch==null)return ;
        let idx=map.get(ch);
        if(!idx){
            idx=this.DocumentIndex();
            map.set(ch,idx);
            if(ch==EOF)idx.isEof=true;
        }
        this.add(idx,doc,offset+1);
    }
    addDoc(didx,doc,offset){
        if(!didx.isEof)this.rank.requestUpdate(didx);
        let map=didx.map;
        let offsets=map.get(doc);
        if(!offsets){
            offsets=[];
            map.set(doc,offsets);
        }
        offsets.push(offset);
    }
    add(idx,doc,offset){
        if(keyIsLetter(idx)){
            this.addChr(idx.map,doc,offset);
        }else{
            this.addDoc(idx,doc,offset);
        }
    }
    toLetterIndex(didx){
        if(didx.isEof)return ;
        let nmap=new Map();
        let c=0;
        for(let [doc, offsets] of didx.map){
            for (let o of offsets){
                this.addChr(nmap,doc,o);
                c++;
            }
        }
        this.rank.remove(didx);
        didx.map=nmap;
        didx.keyType="chr";
        return c;
    }
    calcCount(idx){
        idx=idx||this.root;
        let c=0;
        if(idx.keyType=="doc"){
            for(let [doc, offsets] of idx.map){
                c+=offsets.length;
            }
        }else{
            for(let [chr, sidx] of idx.map){
                c+=this.calcCount(sidx);
            }
        }
        idx.count=c;
        return c;
    }
}
class Index{
    constructor(keyType){
        this.keyType=keyType;
        this.map=new Map();    
    }
}