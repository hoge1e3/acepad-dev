// @hoge1e3/ngram
import * as assert from "assert";
import {Counter} from "@hoge1e3/counter";
import { Key } from "readline";
export const EOF="eof";
export class Document{
    deleted=false;
    constructor(public path:string,
        public content:string,
        public timeStamp:number=Date.now()){
    }
    at(offset:number){
        if(offset==this.content.length)return EOF;
        return this.content[offset];
    }
    slice(b:number,e:number){
        return this.content.substring(b,e);
    }
    toString(){
        return this.path;
    }
    looks(at:number,word:string){
        return this.content.substring(at,at+word.length)==word;
    }
}
export class DocumentSet{
    root=this.LetterIndex();
    rank=new RankedList<DocumentIndex>({
        rankOf(didx: DocumentIndex){
            let c=1;
            for(let [doc, offsets] of didx.map){
                c+=offsets.length;
            }
            return Math.floor(Math.log(c));
        }
    });
    path2doc=new Map<string,Document>();
    constructor (){
    }
    addDocument(doc:Document){
        let old=this.path2doc.get(doc.path);
        if(old){
            old.deleted=true;
        }
        this.path2doc.set(doc.path,doc);
        for(let i=0;i<doc.content.length;i++){
            this.add(this.root,doc,i);
        }
    }
    find(word:string){
        return find(word,this.root);
    }
    async predict(doc:Document,offset:number){
        return await predict(doc,offset,this.root);
    }
    predictWord(doc:Document,offset:number){
        return predictWord(doc,offset,this.root);
    }
    expand(){
        this.rank.updateAll();
        let didx=this.rank.pick();
        if(!didx)return ;
        return this.toLetterIndex(didx);
    }
    calcCount(idx:Index){
        idx=idx||this.root;
        let c=0;
        if(keyIsDocument(idx)){
            for(let [doc, offsets] of idx.map){
                c+=offsets.length;
            }
        }else{
            for(let [chr, sidx] of idx.map){
                c+=this.calcCount(sidx);
            }
        }
        idx.count=c;
        return c;
    }

    //private
    LetterIndex():LetterIndex{
        let lidx:LetterIndex={count:0, map:new Map(), keyType: "chr"};
        return lidx;
    }
    DocumentIndex(isEof:boolean):DocumentIndex{
        let didx:DocumentIndex={count:0, map:new Map(), keyType: "doc",isEof};
        return didx;
    }
    addChr(map:Map<string,Index>,doc:Document, offset:number){
        let ch=doc.at(offset);
        if(ch==null)return ;
        let idx=map.get(ch);
        if(!idx){
            const didx=this.DocumentIndex(ch===EOF);
            map.set(ch,didx);
            //if(ch==EOF)didx.isEof=true;
            idx=didx;
        }
        this.add(idx,doc,offset+1);
    }
    addDoc(didx:DocumentIndex,doc:Document,offset:number){
        if(!didx.isEof)this.rank.requestUpdate(didx);
        let map=didx.map;
        let offsets=map.get(doc);
        if(!offsets){
            offsets=[];
            map.set(doc,offsets);
        }
        /*assert.ok(didx.isEof||
        offset<=doc.content.length,
        doc+":"+offset+" invalid offset");
        assert.ok(!didx.isEof||
        offset==doc.content.length+1,
        doc+":"+offset+" invalid eof offset");*/
        
        offsets.push(offset);
    }
    add(idx:Index,doc:Document,offset:number){
        if(keyIsLetter(idx)){
            this.addChr(idx.map,doc,offset);
        } else /*if(keyIsDocument(idx))*/{
            this.addDoc(idx,doc,offset);
        }
    }
    toLetterIndex(didx:DocumentIndex){
        if(didx.isEof)return ;
        let nmap=new Map<string,Index>();
        let c=0;
        for(let [doc, offsets] of didx.map){
            for (let o of offsets){
                this.addChr(nmap,doc,o);
                c++;
            }
        }
        this.rank.remove(didx);
        const nidx=didx as unknown as LetterIndex;
        nidx.map=nmap;
        nidx.keyType="chr";
        return c;
    }
}
type FindIndexResult={
    index:Index;
    found:string;
    rest:string;
};
function findIndex(word:string,lidx:LetterIndex):FindIndexResult{
    // index is LetterIndex && rest => not found
    // index is DocumentIndex && rest => depends on index content
    // index is LetterIndex && !rest => found
    // index is DocumentIndex && !rest => found
    let i:number;
    for(i=0;i<word.length;i++){
        let _idx=lidx.map.get(word[i]);
        if(!_idx)return {
            // index is LetterIndex && rest => not found
            index:lidx,
            found:word.substring(0,i),
            rest:word.substring(i),
        };
        const idx:Index=_idx;
        if(keyIsDocument(idx)){
            i++;
            // index is DocumentIndex && rest => depends on index content
            // index is DocumentIndex && !rest => found
            return {
                index:idx,
                found:word.substring(0,i),
                rest:word.substring(i),
            };
        }
        lidx=idx;
    }
    // index is LetterIndex && !rest => found
    return {
        index:lidx,
        found:word.substring(0,i),
        rest:word.substring(i),
    };
    
}
type ResultDetail={
    document:Document;
    offset:number;
    prefix:string;
    eof:boolean;
};
function *resultsFrom(index:Index,prefix=""):Generator<ResultDetail> {
    if(keyIsDocument(index)){
        for(let [d,os] of index.map){
            for(let o of os){
                yield {
                    document:d,
                    offset:o,
                    prefix,
                    eof:index.isEof
                };
            }
        }
    }else{
        for(let [ch,idx] of index.map){
            yield* resultsFrom(idx,prefix+(ch===EOF?"":ch));
        }
    }
}
type FindResult={
    document:Document;
    offset:number;
};
function *find(word:string ,rootidx: LetterIndex):Generator<FindResult> {
    let {index,found,rest}=findIndex(word,rootidx);
    if(keyIsLetter(index)&&rest)return ;
    if(!rest){
        for(let {document,offset,prefix,eof} of 
        resultsFrom(index)){
            yield {
                document,
                offset:offset-
                    prefix.length-
                    found.length-
                    (eof?1:0),
            };
        }
    }else{
        for(let {document,offset,prefix} of 
        resultsFrom(index)){
            if(document.looks(offset,rest)){
                yield {
                    document,
                    offset: offset-found.length,
                };
            }
        }            
    }
}
async function predict(doc:Document,offset:number,rootidx:LetterIndex){
    let p=1;
    let c=new Counter();
    while(offset-p>=0){
        let word=doc.content.substring(offset-p,offset);
        let {index,found,rest}=findIndex(word,rootidx);
        if(rest)break ;
        if(keyIsDocument(index))break;
        let sc=p+1;//index.map.size;
        for(let [ch,i] of index.map){
            if(ch===EOF)continue;
            let sc2=i.count||1;
            c.set(ch,sc-1/sc2);
        }
        p++;
    }
    return c.descend();
}
function isAlpha(a:string){
    return a.match(/^\w$/);
}
export type PredictionResult={
    pre:string;
    post:string;
};
function *predictWord(doc:Document,offset:number,rootidx:LetterIndex):Generator<PredictionResult>{
    let oo=offset;
    offset--;
    while(offset>=0&&isAlpha(doc.at(offset)))offset--;
    offset++;
    if(!isAlpha(doc.at(offset)))return ;
    let pre=doc.slice(offset,oo);
    console.log("pw",pre);
    let {index,found,rest}=findIndex(pre,rootidx);
    console.log("pwr",rest);
    for(let w of traverseWords(index)){
        console.log("pww",pre,w);
        yield {
            pre,
            post: w
        };
    }
    
}
function* traverseWords(idx:Index,prefix=""):Generator<string> {
    if(keyIsDocument(idx)){
        yield prefix;return ;
    }
    let ls=[...idx.map].
    map(([ch,i])=>({ch,c:i.count,idx:i})).
    filter(({ch})=>isAlpha(ch)).
    sort(({c:a},{c:b})=>b-a);
    for(let {ch,idx} of ls){
        yield* traverseWords(idx,prefix+ch);
    }
    
}
//let thresh=10;
//type KeyType="doc"|"chr";
function keyIsDocument(idx:Index):idx is DocumentIndex{
    return idx.keyType=="doc";
}
function keyIsLetter(idx:Index):idx is LetterIndex{
    return idx.keyType=="chr";
}
type RankOf<T>=(item:T)=>number;
class RankedList<T>{
    byRank=[] as (Set<T>|null)[];
    rerank=new Set<T>();
    rankOf: RankOf<T>;
    constructor ({rankOf}:{rankOf:RankOf<T>}){
        this.rankOf=rankOf;
    }
    updateAll(){
        for(let item of this.rerank){
            this.add(item);
        }
        this.rerank=new Set<T>();
    }
    requestUpdate(item:T){
        if(this.rerank.has(item))return ;
        this.remove(item);
        this.rerank.add(item);
    }
    add(item:T){
        let r=this.rankOf(item);
        let b=this.byRank;
        b[r]=b[r]||new Set();
        b[r].add(item);
    }
    remove(item:T){
        let r=this.rankOf(item);
        let b=this.byRank;
        b[r]=b[r]||new Set();
        b[r].delete(item);
    }
    pick(){
        let b=this.byRank;
        for(let i=b.length-1;i>=0;i--){
            const bi=b[i];
            if(!bi||bi.size==0){
                b[i]=null;
                if(i==b.length-1)b.length=i;
                continue;
            }
            for(let e of bi){
                bi.delete(e);
                return e;
            }
        }
    }
}
type Index=LetterIndex|DocumentIndex;
/*class Index{
    map=new Map();    
    count=0;
    constructor(public keyType:KeyType){
    }
}*/
interface LetterIndex {
    count:number;
    //isEof?: boolean;
    keyType: "chr";
    map:Map<string, Index>;
};
interface DocumentIndex {
    count:number;
    isEof: boolean;
    keyType: "doc";
    map:Map<Document, number[]>;
}