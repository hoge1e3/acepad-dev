import * as ngram from "@hoge1e3/ngram";
import * as assert from "assert";
/*
cd /jsmod/node_modules/@hoge1e3/ngram/
npm-test
*/
let sh;
function echo(...args){
    sh.echo(...args);
}
export async function main(){
    sh=this;
    let d=new ngram.Document("A","abcc deff adc eedef abc");
    let s=new ngram.DocumentSet();
    s.addDocument(d);
    let scale="";
    for(let i=0;i<d.content.length;i++){
        scale+=(i%10);
    }
    echo(scale,d.content.length);
    echo(d.content);
    traverse(s.root);
    for(let i=0;i<15;i++){
        echo(s.expand());
        s.calcCount();
        for(let word of allSubstr(d.content)){
            //echo(word);
            find(s,word);
        }
    }
    //traverse(s.root);
    //allWords(s.root);
    await predict(s);
    //let {index,found,rest}=s.findIndex("bc");
    //this.echo(index.keyType,found,rest);
    //traverse.call(this,index);
    /*find(s,"ab");
    find(s,"bc");
    find(s,"def");*/
    //for(let s of allSubstr("abc"))echo(s);
}    
function files(dir){
    
}
function q(c){
    return `'${c}'`;
}
function allWords(idx,ctx=""){
    if(idx.keyType=="doc"){
        for(let [doc, offsets] of idx.map){
            echo(q(ctx),doc,offsets.join(" "));
        }
    }else{
        for(let [chr, sidx] of idx.map){
            allWords(sidx,ctx+chr);
        }
    }
}
function* allSubstr(s){
    for(let i=0;i<s.length;i++){
        for(let j=i+1;j<=s.length;j++){
            yield s.substring(i,j);
        }
    }
}
function traverse(idx){
    let p=(...a)=>{
        a.push({n:1});echo(...a);
    };
    p("{");
    for(let [k,v] of idx.map){
        if(v.keyType){
            p(q(k)+": ");traverse(v);
        }else{
            p(k,v);
        }
        p(",");
    
    }
    p("}");
}
function find(ds,word){
    let r=new Set();
    for(let {document,offset} of ds.find(word)){
        //echo(word,document.path,offset);
        assert.ok(document.looks(offset,word),
        [word,document.path,offset].join(","));
        r.add(`${document}:${offset}`);
    }
    let offset=0;
    for(let [p,d] of ds.path2doc){
        while(true){
            let i=d.content.indexOf(word,offset);
            if(i<0)return ;
            offset=i;
            assert.ok(r.has(`${d}:${offset}`),
            `no ${d}:${offset}`);
            offset++;
        }
    }
}
async function predict(ds){
    for(let [p,d] of ds.path2doc){
        for(let i=1;i<d.content.length;i++){
            echo("predict",d.content.substring(i-5,i),"...");
            for(let [k,v] of await ds.predict(d,i)){
                echo(`'${k}'(${v}) `,{n:1});
            }
            echo(" ");
        }
    }
}


