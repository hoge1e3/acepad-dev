// acepad-dot-sync
export function find(dir) {
    let sync = findDotSyncDir(dir);
    dir = sync.up();
    let info = instance(dir);
    const { repof, treef } = info;
    let { name, config } = repof.obj();
    let trdata = treef.obj();
    let treeOfLastCommit = trdata.tree;
    let __id__ = trdata.__id__;
    return Object.assign(info, {
        name,
        __id__, // local __id__ of prev sync
        treeOfLastCommit, //trdata.tree
    });
}
export function instance(dir, inTmp = false) {
    const sync = dir.rel(".sync/");
    const repof = sync.rel(repon);
    const treef = sync.rel(treen);
    const syncignore = dir.rel(".syncignore");
    const subSyncsFile = dir.rel(".subsyncs.json");
    //let subSyncs=undefined as Set<string>|undefined;
    return {
        repof,
        treef,
        dir,
        sync,
        isSubSync(f) {
            return !f.equals(dir) && f.isDir() && f.rel(".sync/").exists();
        },
        inSubSync(f) {
            while (dir.contains(f)) {
                if (this.isSubSync(f))
                    return true;
                f = f.up();
            }
            return false;
        },
        getExcludes() {
            const truncSEP = ((s) => s.replace(/\/$/, ""));
            const excludePaths = [".sync/", ...(this.getConfig().excludes || []), ...(syncignore.exists() ? syncignore.lines() : [])].map(truncSEP);
            const isSubSync = (f) => this.isSubSync(f);
            const subSyncs = new Set();
            const res = (f) => {
                const relPath = f.relPath(dir);
                if (isSubSync(f)) {
                    subSyncs.add(relPath);
                    return true;
                }
                return excludePaths.some(e => truncSEP(relPath) == e);
            };
            res.subSyncs = subSyncs;
            return res;
        },
        updateTree() {
            const lc = this.readTreeFile();
            lc.tree = this.getWorkingTree();
            this.writeTreeFile(lc);
        },
        getConfig() {
            // repof may not exist when downloaded into tmp dir, or checkout only subsync
            if (!repof.exists())
                return { excludes: [] };
            let { config } = this.readRepo();
            return config || { excludes: [] };
        },
        writeRepo(obj) {
            repof.obj(obj);
        },
        readRepo() {
            return repof.obj();
        },
        writeTreeFile(obj) {
            treef.obj(obj);
        },
        readTreeFile() {
            return treef.obj();
        },
        getWorkingTree(writeSubSyncs = false) {
            const excludes = this.getExcludes();
            const tree = dir.getDirTree({
                style: "flat-relative",
                excludes,
            });
            const subSyncs = excludes.subSyncs;
            if (writeSubSyncs && subSyncs) {
                const data = (subSyncsFile.exists() ? subSyncsFile.obj() : {});
                let save = false;
                for (let subSync of subSyncs) {
                    let f = dir.rel(subSync);
                    const w = instance(f);
                    const __id__ = w.readTreeFile().__id__;
                    if (!data[subSync]) {
                        // TODO: which __id__ is newer??
                        save = true;
                        data[subSync] = { __id__ };
                    }
                }
                if (save) {
                    subSyncsFile.obj(data);
                    tree[subSyncsFile.relPath(dir)] = { lastUpdate: subSyncsFile.lastUpdate() };
                }
            }
            return tree;
        },
        init({ name, __id__, config }) {
            if (!sync.exists())
                sync.mkdir();
            this.writeRepo({
                name, config,
            });
            const tree = {};
            this.writeTreeFile({
                __id__,
                tree,
            });
        },
        branch(newname) {
            const r = this.readRepo();
            r.name = newname;
            this.writeRepo(r);
        },
    };
}
const repon = "repo.json";
const treen = "tree.json";
export function findDotSyncDir(dir) {
    for (let d = dir; d; d = d.up()) {
        let s = d.rel(".sync/");
        if (s.exists())
            return s;
    }
    throw new Error(`.sync not found from ${dir}`);
}
export function conflictFile(f, id) {
    let names = f.name().split(".");
    names[0] += `(${id.substring(0, 8)})`;
    return f.sibling(names.join("."));
}
//# sourceMappingURL=dot-sync.js.map