// @hoge1e3/lru

export class Lru{
    constructor (raw={},schema={}){
        this.raw=raw;
        this.schema=schema;
    }
    limit(count) {
        const {schema, raw}=this;
        const keyn=schema.key||"key";
        for (let e of this) {
            count--;
            if (count<0) {
                delete raw[e[keyn]];
            }
        }
        return this;
    }
    add(key,val){
        const {schema, raw}=this;
        let keyn=schema.key;
        let ts=schema.timestamp;
        if(!key) {
            throw new Error("Empty arg");
        }
        const tsval=new Date().getTime();
        if(!val){
            const arg=key;
            if (!keyn && typeof arg==="object") {
                keyn="key";
            }
            if(!keyn || keyn==="this"){
                if (typeof arg!=="string") {
                    throw new Error("Value should be a string");
                }
                key=arg;
                if (!ts || ts==="this") {
                    val=tsval;
                    ts="this";
                } else {
                    val={};
                }
            }else{
                if (typeof arg!=="object") {
                    throw new Error("Value should be an object");
                }
                val={...arg};
                key=val[keyn];
                if (!key) {
                    throw new Error("Key "+keyn+" is not set");
                }
                delete val[keyn];
            }
        }
        ts=ts||"timestamp";
        if(ts!=="this"){
            if (typeof val!=="object") {
                throw new Error("Cannot set "+ts+" to primitive val");
            }
            if (ts in val) {
                throw new Error("Cannot overwrite "+ts+" as a timestamp.");
            }
            val[ts]=tsval;
        } 
        if (typeof key!=="string"){
            throw new Error("Invaid key: "+key);
        }
        const tswritten=(ts==="this"? val: val[ts]);
        if (tswritten!==tsval) {
            throw new Error("invalid timestamp: "+tswritten);
        }
        raw[key]=val;
        return this;
    }
    [Symbol.iterator]() {
        const {schema, raw}=this;
        let ts=schema.timestamp||"timestamp";
        return [...this.iterRaw()].sort(
            (a,b)=>b[ts]-a[ts]
        )[Symbol.iterator]();  
    }
    *iterRaw(){
        const {schema, raw}=this;
        const keyn=schema.key||"key";
        let ts=schema.timestamp||"timestamp";
        for (let key in raw) {
            let val=raw[key];
            if (typeof val==="number") {
                yield {[keyn]: key, [ts]:val};
            } else {
                if (typeof val!=="object") {
                    throw new Error(`Invaild value ${key}=${val}`);
                }
                if (keyn in val && val[keyn]!==key) {
                    throw new Error(`Inconsistent key with val.${keyn}`);
                }
                yield {[keyn]:key, ...val};
            }
        }
    }
}
