export function updater(opt) {
    return {
        update(dst, src) {
            return update(dst, src, opt);
        }
    };
}
function isElement(d) {
    return d.nodeType === Node.ELEMENT_NODE;
}
export function update(dst, src, opt = {}) {
    let { findUpdatable, isUpdatable, isSkippable, props, attr_version, } = opt;
    attr_version = attr_version || "data-version";
    const _props = props || ((d) => ["value", "checked"]);
    const _findUpdatable = findUpdatable || function (s) {
        //console.log("nodeType",s,s.nodeType,Node.ELEMENT_NODE);
        if (!isElement(s))
            return null;
        const id = s.getAttribute("id");
        if (!id)
            return null;
        const found = this.root.querySelector("#" + id);
        //console.log("Find",id,"from",this.root,found);
        return found;
    };
    const _isUpdatable = isUpdatable || function (d, s) {
        if (!isElement(s) || !isElement(d)) {
            return s.nodeType === d.nodeType;
        }
        const id = s.getAttribute("id");
        if (id)
            return id === d.getAttribute("id");
        return s.tagName === d.tagName;
    };
    const _isSkippable = isSkippable || ((d, s) => {
        return isElement(s) && isElement(d) &&
            !!d.getAttribute(attr_version) &&
            d.getAttribute(attr_version) ===
                s.getAttribute(attr_version);
    });
    const updater = {
        root: dst,
        trashed: new Set(),
        trash(dom) {
            updater.trashed.add(dom);
        },
        kept: new Set(),
        keep(dom) {
            updater.trashed.delete(dom);
            updater.kept.add(dom);
        },
    };
    function u(d, s) {
        //console.log("upsub", d.outerHTML, s.outerHTML);
        if (s.nodeType !== d.nodeType) {
            console.log("nodeType!=", d, s);
            throw new Error(`nodeType not match`);
        }
        if (d.nodeType === Node.TEXT_NODE) {
            if (d.textContent !== s.textContent) {
                d.textContent = s.textContent;
            }
            return;
        }
        if (!isElement(s) || !isElement(d))
            return;
        uattr(d, s);
        uprop(d, s);
        let i = 0;
        const ins = (n) => {
            if (d.childNodes[i] !== n) {
                if (n.parentNode === d) {
                    const nind = Array.from(d.childNodes).indexOf(n);
                    if (nind < i) {
                        //     nind          i
                        //  A  B(n)  C  D    E
                        //  A   C    D  B(n) E
                        d.insertBefore(n, d.childNodes[i]);
                    }
                    else {
                        //      i           nind 
                        //  A   B   C   D   E(n)  F
                        //  A   Bx  Cx  Dx  E(n)  F
                        //                        i
                        for (; i < nind; i++) {
                            updater.trash(d.childNodes[i]);
                        }
                        i++;
                    }
                }
                else {
                    d.insertBefore(n, d.childNodes[i]);
                    i++;
                }
            }
            else
                i++;
            updater.keep(n);
        };
        const srcNodes = Array.from(s.childNodes);
        for (let sc of srcNodes) {
            const di = d.childNodes[i];
            const dc = (di && _isUpdatable.call(updater, di, sc) ?
                di :
                _findUpdatable.call(updater, sc, d));
            //console.log("fu", sc, dc);
            if (!dc) {
                ins(sc);
            }
            else {
                ins(dc);
                if (!_isSkippable.call(updater, dc, sc)) {
                    u(dc, sc);
                }
            }
        }
        for (; i < d.childNodes.length; i++) {
            updater.trash(d.childNodes[i]);
        }
    }
    function uattr(d, s) {
        const ds = new Set();
        for (let a of Array.from(d.attributes)) {
            ds.add(a.name);
        }
        for (let a of Array.from(s.attributes)) {
            if (d.getAttribute(a.name) !== a.value) {
                d.setAttribute(a.name, a.value);
            }
            ds.delete(a.name);
        }
        for (let n of ds) {
            d.removeAttribute(n);
        }
    }
    function uprop(d, s) {
        const ds = new Set();
        for (let a of _props(d)) {
            ds.add(a);
        }
        const [_d, _s] = [d, s];
        for (let a of _props(s)) {
            if (_d[a] !== _s[a]) {
                _d[a] = _s[a];
            }
            ds.delete(a);
        }
        for (let n of ds) {
            delete _d[n];
        }
    }
    u(dst, src);
    for (let t of updater.trashed) {
        //console.log("trash", t);
        t.parentNode.removeChild(t);
    }
}
//# sourceMappingURL=dom-updater.js.map