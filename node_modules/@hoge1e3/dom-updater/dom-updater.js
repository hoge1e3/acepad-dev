// @hoge1e3/dom-updater
export function updater(opt){
    return {
        update(dst,src){
            return update(dst,src,opt);
        }
    };
}
export function update(dst,src,opt={}){
    let {
        findUpdatable,
        isUpdatable,
        isSkippable,
        props,
    }=opt;
    props=props||((d)=>["value","checked"]);
    findUpdatable=findUpdatable||function (s){
        //console.log("nodeType",s,s.nodeType,Node.ELEMENT_NODE);
        if (s.nodeType!==Node.ELEMENT_NODE) return;
        const id=s.getAttribute("id");
        if (!id) return;
        const found=this.root.querySelector("#"+id);
        //console.log("Find",id,"from",this.root,found);
        return found;
    };
    isUpdatable=isUpdatable||function (d,s){
        if (s.nodeType!==Node.ELEMENT_NODE) {
            return s.nodeType===d.nodeType;
        }
        const id=s.getAttribute("id");
        if (id) return id===d.getAttribute("id");
        return s.tagName===d.tagName;
    };
    isSkippable=isSkippable||(()=>false);
    const updater={
        root:dst,
        trashed:new Set(),
        trash(dom){
            updater.trashed.add(dom);
        },
        kept:new Set(),
        keep(dom){
            updater.trashed.delete(dom);
            updater.kept.add(dom);
        },
    };
    function u(d, s){
        //console.log("upsub", d, s);
        if (s.nodeType!==d.nodeType){
            console.log("nodeType!=", d, s);
            throw new Error(`nodeType not match`);
        }
        if (d.nodeType===Node.TEXT_NODE) {
            if (d.textContent!==s.textContent){
                d.textContent=s.textContent;
            }
            return;
        }
        uattr(d, s);
        uprop(d, s);
        let i=0;
        const ins=(n)=>{
            if(d.childNodes[i]!==n){
                if (n.parentNode===d) {
                    const nind=[...d.childNodes].indexOf(n);
                    if (nind<i) {
                        //     nind          i
                        //  A  B(n)  C  D    E
                        //  A   C    D  B(n) E
                        d.insertBefore(n,d.childNodes[i]);
                    } else {
                        //      i           nind 
                        //  A   B   C   D   E(n)  F
                        //  A   Bx  Cx  Dx  E(n)  F
                        //                        i
                        for (;i<nind;i++) {
                            updater.trash(d.childNodes[i]);
                        }
                        i++;
                    }
                }else{
                    d.insertBefore(n,d.childNodes[i]);
                    i++;
                }
            } else i++;
            updater.keep(n);
        };
        const srcNodes=[...s.childNodes];
        for(let sc of srcNodes){
            const di=d.childNodes[i];
            const dc=(
                di&&isUpdatable.call(updater, di, sc)?
                di:
                findUpdatable.call(updater,sc,d)
            );
            //console.log("fu", sc, dc);
            if(!dc){
                ins(sc);
            }else{
                ins(dc);
                if(!isSkippable.call(updater,dc,sc)){
                    u(dc,sc);
                }
            }
        }
        for(;i<d.childNodes.length;i++){
            updater.trash(d.childNodes[i]);
        }
    }
    function uattr(d, s){
        const ds=new Set();
        for(let a of d.attributes){
            ds.add(a.name);
        }
        for(let a of s.attributes){
            if(d.getAttribute(a.name)!==a.value){
                d.setAttribute(a.name, a.value);
            }
            ds.delete(a.name);
        }
        for (let n of ds) {
            d.removeAttribute(n);
        }
    }
    function uprop(d, s){
        const ds=new Set();
        for(let a of props(d)){
            ds.add(a.name);
        }
        for(let a of props(s)){
            if(d[a]!==s[a]){
                d[a]=s[a];
            }
            ds.delete(a.name);
        }
        for (let n of ds) {
            delete d[n];
        }
    }
    u(dst, src);
    for(let t of updater.trashed){
        console.log("trash", t);
        t.parentNode.removeChild(t);
    }
}