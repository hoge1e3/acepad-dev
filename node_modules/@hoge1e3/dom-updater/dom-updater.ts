// @hoge1e3/dom-updater
type Options={
    findUpdatable?:(s:Node,d:Node)=>ChildNode|null,
    isUpdatable?:(d:Node,s:Node)=>boolean,
    isSkippable?:(d:Node,s:Node)=>boolean,
    props?:(d:Node)=>string[],
    attr_version?:string,
}
export function updater(opt: Options){
    return {
        update(dst:HTMLElement,src:HTMLElement){
            return update(dst,src,opt);
        }
    };
}
function isElement(d:Node):d is HTMLElement{
    return d.nodeType===Node.ELEMENT_NODE;
}
export function update(dst:HTMLElement,src:HTMLElement,opt={} as Options){
    let {
        findUpdatable,
        isUpdatable,
        isSkippable,
        props,
        attr_version,
    }=opt;
    attr_version=attr_version||"data-version";
    const _props=props||((d)=>["value","checked"]);
    const _findUpdatable=findUpdatable||function (this:typeof updater,s:Node):ChildNode|null{
        //console.log("nodeType",s,s.nodeType,Node.ELEMENT_NODE);
        if (!isElement(s)) return null;
        const id=s.getAttribute("id");
        if (!id) return null;
        const found=this.root.querySelector("#"+id) as (ChildNode|null);
        //console.log("Find",id,"from",this.root,found);
        return found;
    };
    const _isUpdatable=isUpdatable||function (d:Node,s:Node){
        if (!isElement(s)||!isElement(d)) {
            return s.nodeType===d.nodeType;
        }
        const id=s.getAttribute("id");
        if (id) return id===d.getAttribute("id");
        return s.tagName===d.tagName;
    };
    const _isSkippable=isSkippable||((d:Node, s:Node)=>{
        return isElement(s) && isElement(d) &&
            !!d.getAttribute(attr_version) &&
            d.getAttribute(attr_version)===
            s.getAttribute(attr_version);
    });
    const updater={
        root:dst,
        trashed:new Set<Node>(),
        trash(dom:Node){
            updater.trashed.add(dom);
        },
        kept:new Set<Node>(),
        keep(dom:Node){
            updater.trashed.delete(dom);
            updater.kept.add(dom);
        },
    };
    function u(d:Node, s:Node){
        //console.log("upsub", d.outerHTML, s.outerHTML);
        if (s.nodeType!==d.nodeType){
            console.log("nodeType!=", d, s);
            throw new Error(`nodeType not match`);
        }
        if (d.nodeType===Node.TEXT_NODE) {
            if (d.textContent!==s.textContent){
                d.textContent=s.textContent;
            }
            return;
        }
        if (!isElement(s) || !isElement(d)) return;
        uattr(d, s);
        uprop(d, s);
        let i=0;
        const ins=(n:ChildNode)=>{
            if(d.childNodes[i]!==n){
                if (n.parentNode===d) {
                    const nind=Array.from(d.childNodes).indexOf(n);
                    if (nind<i) {
                        //     nind          i
                        //  A  B(n)  C  D    E
                        //  A   C    D  B(n) E
                        d.insertBefore(n,d.childNodes[i]);
                    } else {
                        //      i           nind 
                        //  A   B   C   D   E(n)  F
                        //  A   Bx  Cx  Dx  E(n)  F
                        //                        i
                        for (;i<nind;i++) {
                            updater.trash(d.childNodes[i]);
                        }
                        i++;
                    }
                }else{
                    d.insertBefore(n,d.childNodes[i]);
                    i++;
                }
            } else i++;
            updater.keep(n);
        };
        const srcNodes=Array.from(s.childNodes);
        for(let sc of srcNodes){
            const di=d.childNodes[i];
            const dc:ChildNode|null=(
                di&&_isUpdatable.call(updater, di, sc)?
                di:
                _findUpdatable.call(updater,sc,d)
            );
            //console.log("fu", sc, dc);
            if(!dc){
                ins(sc);
            }else{
                ins(dc);
                if(!_isSkippable.call(updater,dc,sc)){
                    u(dc,sc);
                }
            }
        }
        for(;i<d.childNodes.length;i++){
            updater.trash(d.childNodes[i]);
        }
    }
    function uattr(d:HTMLElement, s:HTMLElement){
        const ds=new Set<string>();
        for(let a of Array.from(d.attributes)){
            ds.add(a.name);
        }
        for(let a of Array.from(s.attributes)){
            if(d.getAttribute(a.name)!==a.value){
                d.setAttribute(a.name, a.value);
            }
            ds.delete(a.name);
        }
        for (let n of ds) {
            d.removeAttribute(n);
        }
    }
    function uprop(d:HTMLElement, s:HTMLElement){
        const ds=new Set<string>();
        for(let a of _props(d)){
            ds.add(a);
        }
        const [_d,_s]=[d as any, s as any];
        for(let a of _props(s)){
            if(_d[a]!==_s[a]){
                _d[a]=_s[a];
            }
            ds.delete(a);
        }
        for (let n of ds) {
            delete _d[n];
        }
    }
    u(dst, src);
    for(let t of updater.trashed){
        //console.log("trash", t);
        t.parentNode!.removeChild(t);
    }
}