/*global ace*/
var $singleLineEditor = function(el) {
    var renderer = new ace.VirtualRenderer(el);
    renderer.$maxLines = 1;
    var editor = new ace.Editor(renderer);

    editor.setHighlightActiveLine(false);
    editor.setShowPrintMargin(false);
    editor.renderer.setShowGutter(false);
    editor.renderer.setHighlightGutterLine(false);

    editor.$mouseHandler.$focusTimeout = 0;
    editor.$highlightTagPending = true;
    const oo=editor.onTextInput;
    editor.onTextInput=function (...args){
        const a=args[0];
        if(typeof a==="string" && a.match(/\n/)){
            args[0]=a.replace(/\n/,"");
            if(args.length==1&&!args[0])return ;
            console.log("ont",args);
        }
        return oo.call(this,...args);
    };
    return editor;
};

export function rect(e,base){
    base=base||document.body;
    let b=base.getBoundingClientRect();
    let r=e.getBoundingClientRect();
    return {
        left: r.left-b.left,
        top: r.top-b.top,
        width: r.width,
        height: r.height,
    };
    /*
    const test=e;
    const inf={
        left: test.offsetLeft,
        top: test.offsetTop,
        width: test.offsetWidth,
        height: test.offsetHeight,
    };//getElementRelativeInfo(test);
    return inf;*/
}
const acted=Symbol("acted");
export function activate1(base,element,opt){
    if(element[acted])return ;
    element[acted]=true;
    element.addEventListener("click",function (e){
      const editor=overlay(this,{base,...opt});
      let {row,column}=editor.renderer.
        pixelToScreenCoordinates(e.clientX,e.clientY); 
      editor.gotoLine(row+1,column);
      console.log("act1",e.clientX,e.clientY,row,column);
    });
}
export function activate(container,opt){
    if(opt.dynamic){
        const o={...opt};
        delete o.dynamic;
        const t=setInterval(
            ()=>{
                try{
                    activate(container,o);
                }catch(e){
                    clearTimeout(t);
                    throw e;
                }
            },100);
        return t;
    }
    for(let e of container.querySelectorAll("input")){
        activate1(container,e,opt);
    }
    for(let e of container.querySelectorAll("textarea")){
        activate1(container,e,opt);
    }
}
export function overlay(e,opt={}){
    const test=e;
    const cs=(getComputedStyle(test));
    const fsz=cs.getPropertyValue("font-size");
    const base=opt.base||document.body;
    
    const overp=base;//document.body;//test.offsetParent;//document.querySelector("#over");
    const over=document.createElement("div");
    const inf=rect(e,base);
    console.log("inf",inf);
    over.setAttribute("style",`
    position: absolute;
    left: ${inf.left}px;
    top: ${inf.top}px;
    width: ${inf.width}px;
    height: ${inf.height}px;
    `);
    overp.appendChild(over);
    const editor= e.tagName.toLowerCase()==="input"?
        $singleLineEditor(over):ace.edit(over);
    //editor.textInput.getElement().setAttribute("readonly",true);
    editor.session.setValue(e.value);
    editor.setFontSize(fsz);
    editor.renderer.setShowGutter(false);
    editor.on("input",(ev)=>{
        e.value=editor.session.getValue();
        e.dispatchEvent(new Event("input"));
    });
    editor.on("blur",(ev)=>{
        e.value=editor.session.getValue();
        e.dispatchEvent(new Event("change"));
        if(opt.ondestroy){
            opt.ondestroy({editor});
        }
        editor.destroy();
        over.parentNode.removeChild(over);
    });
    if(opt.oncreate){
        opt.oncreate({editor});
    }
    editor.focus();
    return editor;
}
