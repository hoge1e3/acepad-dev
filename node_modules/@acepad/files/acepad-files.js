// acepad-files
//import timer from "pause-me";
//assert
import {ok} from "assert";
import {match} from "textmatcher";
import {setMode} from "@acepad/mode-shell";
import {convertStack} from "@acepad/os";
import {hasTrace} from "@acepad/debug";
import * as recents from "./recents.js";
import * as pos from "./pos.js";
import {shd, init as initAutoSync} from "./autoSync.js";
import {sibling} from "@acepad/here";
import pNode from "petit-node";
import {sessionInfo, createSession, recentInfos,findSession, removeSession} from "@acepad/sessions";
let an;
/*const an=await pNode.import(sibling(
    import.meta.url,"annotations.js"));*/
export async function setAnnotations(...a){
    an=an||await pNode.import(sibling(
    import.meta.url,"annotations.js"));
    return an.setAnnotations(...a);
}
function stripPrompt(line){
    return line.replace(/^sh:\s*/,"");
}
export function current(sh){
    const acepad=sh.$acepad;
    const editor=acepad.getMainEditor();
    const session=editor.session;
    const si=sessionInfo(session);
    return si.file;
}
/*global ace*/
export function openFile(sh,fn,opt){
    const acepad=sh.$acepad;
    const {getMainEditor}=acepad;
    const editor=getMainEditor();
    initAutoSync(editor);
    pos.initAutoSave(acepad);
    let f;
    const ns=(v)=>typeof v==="number"||typeof v==="string";
    const move=()=>{
        console.log("loc",opt);
        if(opt&&
        ns(opt.row)&&ns(opt.column)
        )editor.gotoLine(opt.row-0,opt.column-0);
    };
    if(typeof fn=="string"){
        f=sh.resolve(fn).resolveLink();
    }else{
        f=fn.resolveLink();
        fn=f.name();
    }
    try {
        recents.add(sh, f);
    }catch(e){
        console.error(e);
        alert(e);
    }
    let s=findSessionByFile(f);
    if(s){
        editor.setSession(s);
        move();
        return s;
    }
    if(f.isDir()){
        s=createDirList(sh,f);
        editor.setSession(s);
        return s;
    }
    if(!f.exists())f.text("");
    let text=f.text();
    //let t;
    s=createSession({
        text,
        file:f,
        type:"file",
        ts:f.lastUpdate(),
        val:text,
        onActivated(){
        },
        onDeactivated(){
            shd("pause",f);
            //t.pause();
        },
        commands:{
            F7(){
                openFile(sh, f.up());
            },
        }
    });
    let si=sessionInfo(s);
    si.on("activate",({oldSession})=>{
        if(!f.exists()){
            removeSession(s);
            let o=findSession(oldSession);
            if(o)setTimeout(()=>
            editor.setSession(o),100);
            return ;
        }   
        shd("resume",f);
    });
    editor.setSession(s);
    if(!opt){
        const {row,column}=pos.get(f);
        editor.gotoLine(row-0,column-0);
    }
    //locate(s,column,row);
    const mode=modeMap[f.ext()];
    if(mode){
        s.setMode(mode);
    }else if(f.text().match(/^(\/\/|#)!run/)){
        s.setMode("ace/mode/javascript");
    }
    move();
    return s;
}
export const modeMap={
    ".html":"ace/mode/html",
    ".php":"ace/mode/php",
    ".c":"ace/mode/c",
    ".py":"ace/mode/python",
    ".json":"ace/mode/json",
    ".css":"ace/mode/css",
    ".js":"ace/mode/javascript",
    ".ts":"ace/mode/typescript",
    ".tonyu":"ace/mode/tonyu",
    ".":"ace/mode/",
};
const unh=Symbol("unhacked");
function cdhacked(_sh,dir){
    const unhacked=_sh[unh]||_sh;
    const sh=_sh.clone();
    sh.cd(dir);
    const hacked=sh;
    hacked[unh]=unhacked;
    hacked.cd=function (dir){
        openFile(this,this.resolve(dir));  
    };
    hacked.clone=function (){
        const nsh=unhacked.clone.call(this);
        nsh[unh]=null;
        nsh.cd=unhacked.cd;
        nsh.clone=unhacked.clone;
        return nsh;
    };
    return sh;
}
export function createDirList(sh,dir){
    const acepad=sh.$acepad;
    const {locate,print,currentLine}=acepad;
    const resolve=(n)=>sh.resolve(n);//dir.rel(n);
    sh=cdhacked(sh,dir);
    /*sh=sh.clone();
    sh.cd(dir);*/
    sh.setout({
        log(...a){
            print(s,...a);    
        }
    });
    let editor, reqReload=true;
    function reload(editor) {
        reqReload=true;
        onActivated(editor);
    }
    function onActivated(_editor){
        editor=_editor;
        if (!reqReload) return;
        reqReload=false;
        ok(editor.session,"why session undefined");
        editor.session.setValue(
        dir.listFiles().
        sort((a,b)=>
            b.lastUpdate()-
            a.lastUpdate()
        ).map((p)=>p.name())
        .join("\n")+            
        "\n../"+
        "\nnew: "+
        "\nctrl-t: rename ctrl-e: remove\n"+
        dir+
        "\nsh: \n"+sh.history().map(s=>`sh: ${s}`).join("\n"));
    }
    let s=createSession({
        type:"files",
        file:dir,
        name:dir.name(),
        onActivated,
        commands:{
            "ctrl-s":function (){
                locate(0,null);
                print("sh: ");
            },
            "ctrl-e":function (){
                locate(0,null);
                print("rm: ");
            },
            "ctrl-t":function (){
                const fn=currentLine();
                locate(0,null);
                print("mv: ");
                locate(100,null);
                print(" to: "+fn);
            },
            F6(){
                reload(editor);
            },
            F7(){
                openFile(sh, dir.up());
            },
            return: onEnter
        },
    });
    setMode(s,{
        sh,
        getContext(editor,session,pos,prefix){
            const line=session.getLine(pos.row);
            if(!line.match(/^sh:/))return "file";
            let picked=stripPrompt(line);
            let c=pos.column-(line.length-picked.length);
            let secondArg=picked.substring(0, c-prefix.length).match(/\s$/);
            if(secondArg)return "file";
            else return "command";
        }
    });
    function onEnter(e){
        let rm,mv;
        let f;
        let pos;
        const ex=(c)=>{
            locate.lineEnd(s);
            print(s,"\n");
            sh.addHist(c);
            Promise.resolve(sh.exec(c)).then((r)=>sh.echo(r),(e)=>{
                e=convertStack(e);
                print(e.stack||e);
            });   
        };
        match(currentLine(),
            /^new: *(\S+)/,
            (_,_0,n)=>{
                f=resolve(n);
                if(!f.exists()) {
                    if (n.match(/\/$/)) {
                        f.mkdir();
                    } else {
                        f.text("");
                    }
                }
                return n;
            },
            /^rm:? *(.+)/,
            (_,_0,n)=>{
                f=resolve(n);
                rm=true;
                return n;
            },
            /^mv:? *(\S+) +to: +(\S+)/,
            (_,_0,n,t)=>{
                f=resolve(n);
                mv=resolve(t);
                return n;
            },
            /^sh: *(.+)/,
            (_,_o,c)=>ex(c), 
            (line)=>{
                const tr=hasTrace(line);
                if(tr){
                    f=tr.file;
                    pos=tr;
                }else{
                    f=resolve(line);
                }
            });
        if(!f)return ;
        if(!f.exists()){
            ex(currentLine());
            return ;
        }
        if(rm){
            if(confirm("remove "+f.name()+"?")){
                f.rm();
                reload(editor);
            }
        }else if(mv){
            if(mv.exists()){
                alert(`${mv.name()} exists`);
            }else{
                f.moveTo(mv);
                reload(editor);
            }
        }else{
            openFile(sh,f,pos);
        }
    }
    return s;
}
export function findSessionByFile(f){
    return findSession((s,si)=>si.file&&
        si.file.equals(f));
}
export function createSessionListWithRecents(sh){
    const acepad=sh.$acepad;
    const editor=acepad.getMainEditor();
    removeSession("*sessions*");
    let rf;
    const s=createSession({
        type:"sessions",
        name:"*sessionsF*",
        onActivated(editor){
            const opened=new Set();
            s.setValue("");
            for(let si of recentInfos()){
                if(si.session===s)continue;
                acepad.print(s,si.name+"\n");
                if(si.file)opened.add(si.file.path());
                rf=rf||si.file;
            }
            for(let f of recents.list(sh)){
                rf=rf||f;
                if(opened.has(f.path()))continue;
                acepad.print(s,f.path()+"\n");
            }
            const home=sh.$home;
            if(home && !opened.has(home)){
                acepad.print(s,home+"\n");
            }
            acepad.locate(s,0,0);
        },
        commands: {
            return() {
                const line=acepad.currentLine();
                const s=findSession(line);
                if(s){
                    editor.setSession(s);
                }else{
                    const f=sh.resolve(line,true);
                    openFile(sh,f);
                }
            },
            F7:()=>{
                openFile(sh,rf);
            },
        },
    });
    return s;
}
