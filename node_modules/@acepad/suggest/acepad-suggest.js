//!run
/*global $*/
import {Document, DocumentSet} from "@hoge1e3/ngram";
import * as assert from "assert";
import {timer} from "@hoge1e3/idle-timer";
import {createProxy} from "@acepad/worker";
const timeout=(t)=>new Promise(s=>setTimeout(s,t));
import {sibling} from "@acepad/here";
export async function main(){
  const usew=1;//process.env.useSuggestWorker;
  const ss=await createProxy(sibling(
    import.meta.url,"suggest-worker.js"));
    let guides=[];
    const exts=[".js",".ts",".json"];
    let dir=this.resolve();
  ss.init(dir.path());
    //let s=new DocumentSet();
    let caps={"\n":"En",
        " ":"Sp",
        "\t":"Tb",
    };
    let a=this.$acepad;
    async function para(){
      let i=0;
      for(let f of dir.recursive()){
            i++;
            if(i%10==0)await timeout(1);
            if(!exts.includes(f.ext()))continue;
            let d=new Document(f.relPath(dir),f.text());
            s.addDocument(d);
        }
        console.log("para1",i);
        for(i=0;i<300000;i++){
            let p=s.expand();
            //sug.text(p);
            if(p<4)break;
            if(i%10==0)await timeout(1);
            if(i%5000==0) {
        //console.log("para2",i,p);
              s.calcCount();
            }
        }
        s.calcCount();
        
    }
    await timeout(1);
    if(!usew)para();
    let sug=$($(".suggest-inner")[0]);
    
    const txt2b=a.textToButton();
    const idle=timer(50);
    const dopre=async()=>{
        let e=a.getCurrentEditor();
        if(!e)return ;
        if(!e.session)return ;
        sug.empty();
        removeGuides();
        await predictw(e.session);
        await predict(e.session);
    };
    idle.on("idle",dopre);
    a.events.on("renderModifierState",()=>idle.active());
    
    function removeGuides(){
        for(let g of guides) g.remove();
    }
    //this.echo("ready");
    function btn(w){
        let b= $("<button>").
            css({
                border:"1px solid black",
            padding:"15px",fontSize:"15px"}).
            attr({"data-text":w}).
            text(caps[w]||w);
        a.initKey(b[0]);
        return b;
    }
    function di(session){
        const r=session.getSelection().getRange().start;
        const i=session.doc.positionToIndex(r);
        const d=new Document("p",session.getValue());
        return {d,i};
    }
    async function predict(session){
        const {d,i}=di(session);
               let pr=await ss.predict(d.content,i);
        //let pr=await s.predict(d,i);
        let c=0;
        guides=[];
        for(let [w,_c] of pr){
            if(c<10){
                let b=btn(w);
                b.appendTo(sug);
            }
            const g=showGuide(w,c);
            if(g)guides.push(g);
            if(c++>10)break;
        }
        /*let c=textToButton();
    guides=sortValues(ngram.get(pre)).map((k,i)=>{
        if(!c[k])return ;
        i=10-i;
        if(i<=0)return ;
        return showGuide(c[k],i);
    })*/
    }
    function showGuide(k,i){
        if(!txt2b[k])return ;
        i=10-i;
        if(i<=0)return ;
        return a.showGuide(txt2b[k],i);
    }
    function isAlpha(a){
        return a.match(/^\w$/);
    }
    async function predictw(session){
        let {d,i}=di(session);
        let c=0;
        d.content=d.content.substring(0,i);
        let res="";
        while(true){
            let pr=await ss.predict(d.content,i);
            //let pr=await s.predict(d,i);
            if(!pr)break;
            if(!pr[0])break;
            let [w,_]=[...pr].shift();
            //console.log("ww",w);
            if(!isAlpha(w))break;
            d.content+=w;
            res+=w;
            i++;
            if(res.length>32)break;
        }
        if(!res)return ;
        //console.log("wr",res);
        let b=btn(res);
        b.appendTo(sug);
        /*for(let {post:w} of pr){
            let b=btn(w);
            b.appendTo(sug);
            if(++c>0)break;
        }*/
    }
}
