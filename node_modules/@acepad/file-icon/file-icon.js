import * as fs from "node:fs";
import * as path from "node:path";
let currentPath = process.cwd(); // 初期ディレクトリ
//---
//import process from "node:process";
addEventListener("unhandledrejection",(e)=>alert(e));
addEventListener("error",(e)=>alert(e));

let selectedItems = new Set();
let clipboard = null;

const fileArea = document.getElementById("fileArea");
const backButton = document.getElementById("backButton");
const currentPathSpan = document.getElementById("currentPath");
const menuBar = document.getElementById("menuBar");
const uploadButton = document.getElementById("uploadButton");
const fileInput = document.getElementById("fileInput");
uploadButton.onclick = () => {
  fileInput.click();
};
// ロングタップ検出
let pressTimer;

export async function renderDirectory(dirPath) {
  clearTimeout(pressTimer);
  pressTimer=null;
  currentPath = dirPath;
  currentPathSpan.textContent = dirPath;

  fileArea.innerHTML = "";
  selectedItems.clear();
  updateMenu();

  try {
    const files = await fs.promises.readdir(dirPath, { withFileTypes: true });

    for (const entry of files) {
      const item = document.createElement("div");
      item.className = "item";
      const fullPath = path.join(dirPath, entry.name);

      const icon = document.createElement("div");
      icon.className = "icon";
      icon.textContent = entry.isDirectory() ? "📁" : "📄";

      const label = document.createElement("div");
      label.className = "label";
      label.textContent = entry.name;

      // 通常クリック: フォルダのみ開く
      //item.addEventListener("click" , ()=>click());
      function click()  {
        //alert(entry+"");
        if(selectedItems.size>0){
          toggleSelection(fullPath, item);
        }else if (entry.isDirectory()) {
          renderDirectory(fullPath);
        } else {
          const ev = new CustomEvent("openfile", {
            detail: { path: fullPath },
            bubbles: true
          });
          dispatchEvent(ev);
        }
      }

      item.addEventListener("mousedown", startPress);
      item.addEventListener("touchstart", startPress);
      item.addEventListener("mouseup", cancelPress);
      item.addEventListener("mouseleave", cancelPress);
      item.addEventListener("touchend", cancelPress);

      function startPress(e) {
        e.preventDefault();
        pressTimer = setTimeout(() => {
          toggleSelection(fullPath, item);
          pressTimer=null;
        }, 500);
      }
      function cancelPress() {
        if(pressTimer){
          clearTimeout(pressTimer);
          pressTimer=null;
          click();
        }
      }

      item.appendChild(icon);
      item.appendChild(label);
      fileArea.appendChild(item);
    }
  } catch (err) {
    alert("Error reading directory: " + err.message);
  }
}

function toggleSelection(fullPath, itemElem) {
  if (selectedItems.has(fullPath)) {
    selectedItems.delete(fullPath);
    itemElem.classList.remove("selected");
  } else {
    selectedItems.add(fullPath);
    itemElem.classList.add("selected");
  }
  updateMenu();
}

function updateMenu() {
  menuBar.innerHTML = "";
  if (selectedItems.size === 0 && !clipboard) {
    menuBar.style.display = "none";
    return;
  }

  menuBar.style.display = "flex";

  if (selectedItems.size > 0) {
    addMenuButton("Cut", () => {
      clipboard = { action: "cut", items: [...selectedItems] };
      selectedItems.clear();
      renderDirectory(currentPath);
    });
    addMenuButton("Copy", () => {
      clipboard = { action: "copy", items: [...selectedItems] };
      selectedItems.clear();
      renderDirectory(currentPath);
    });
    addMenuButton("Delete", async () => {
      for (const file of selectedItems) {
        try {
          const stat = await fs.promises.stat(file);
          if (stat.isDirectory()) {
            await fs.promises.rm(file, { recursive: true, force: true });
          } else {
            await fs.promises.unlink(file);
          }
        } catch (e) {
          alert("Failed to delete " + file + ": " + e.message);
        }
      }
      selectedItems.clear();
      renderDirectory(currentPath);
    });
  }

  if (clipboard) {
    addMenuButton("Paste", async () => {
      for (const file of clipboard.items) {
        const dest = path.join(currentPath, path.basename(file));
        try {
          if (clipboard.action === "copy") {
            const stat = await fs.promises.stat(file);
            if (stat.isDirectory()) {
              await copyDir(file, dest);
            } else {
              await fs.promises.cp(file, dest);
            }
          } else if (clipboard.action === "cut") {
            await fs.promises.rename(file, dest);
          }
        } catch (e) {
          alert("Failed to paste " + file + ": " + e.message);
        }
      }
      clipboard = null;
      renderDirectory(currentPath);
    });
  }
}

function addMenuButton(label, handler) {
  const btn = document.createElement("button");
  btn.textContent = label;
  btn.onclick = handler;
  menuBar.appendChild(btn);
}

async function copyDir(src, dest) {
  await fs.promises.mkdir(dest, { recursive: true });
  const entries = await fs.promises.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const s = path.join(src, entry.name);
    const d = path.join(dest, entry.name);
    if (entry.isDirectory()) {
      await copyDir(s, d);
    } else {
      await fs.promises.cp(s, d);
    }
  }
}

backButton.onclick = () => {
  const parent = path.dirname(currentPath);
  if (parent !== currentPath) {
    renderDirectory(parent);
  }
};
fileInput.addEventListener("change", async () => {
  if (!fileInput.files || fileInput.files.length === 0) return;

  for (const file of fileInput.files) {
    const dest = path.join(currentPath, file.name);

    // File オブジェクトを ArrayBuffer 経由で Node Buffer に変換して保存
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    try {
      await fs.promises.writeFile(dest, buffer);
    } catch (e) {
      alert("Failed to upload " + file.name + ": " + e.message);
    }
  }

  fileInput.value = ""; // 選択状態をクリア
  renderDirectory(currentPath); // 再描画
});
// 初期表示
//renderDirectory(currentPath);
//alert(3);