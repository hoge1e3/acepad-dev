// typescript

//import {initTypescript} from "https://unpkg.com/petit-ts/dist/index.js";
//import 
//const {fs, os, path, process}=globalThis.FS.nodePolyfill;
import {require, FS} from "petit-node";
import * as path from "path";
import {wrap} from "@hoge1e3/splashscreen";
async function extract() {
//r=await fetch("http://unpkg.com/petit-ts/dist/node_modules.zip"); await r.arrayBuffer()
    async function unzip(zipurl,dst) {
        const r=await fetch(zipurl);
        const a=await r.arrayBuffer();
        const zipn=tmp.rel(zipurl.replace(/[^\w\d]/g,"_")+".zip");
        zipn.setBytes(a);
        await FS.zip.unzip(zipn, dst,{v:1});
    }
    //FS.mount("/tmp/","ram");
    const tmp=FS.get("/tmp/ts/");
    tmp.mkdir();
    const ndm=tmp.rel("node_modules/");
    await unzip("https://unpkg.com/petit-ts@1.0.4/dist/node_modules.zip", ndm);
    const ts=require("typescript",ndm);
    const ln=FS.get("/node_modules/");
    if (ln.isLink()) ln.rm();
    ln.link(ndm);
    // tsc does not see NODE_PATH
    /*FS.setEnv("NODE_PATH",
      [tmp.rel("node_modules/").path(),
      ...(FS.getEnv("NODE_PATH")||"").split(":")
      ].join(":")
    );*/
    return ts;
}
const ts=await wrap(extract,"loading tsc")();
// from "https://unpkg.com/petit-fs/dist/index.js";
/*const require=(module)=>{
    if (module==="fs") return fs;
    if (module==="os") return os;
    if (module==="path") return path;
    return null;
};
import {PathUtil} from "@hoge1e3/fs";*/
// Mount RAM disk on /tmp/
//fs.mountSync("/tmp/","ram");
// Expand typescript lib files to /tmp/ts/
//fs.mkdirSync("/tmp/ts/");
/*function createLoggingProxy(name,target) {
    return new Proxy(target, {
        get(obj, prop) {
            const originalValue = obj[prop];

            if (typeof originalValue === 'function') {
                return function (...args) {
                    console.log(`${name}.${prop}`, args);
                    
                    const result = originalValue.apply(obj, args);
                    
                    console.log(`Return value:`, result);
                    return result;
                };
            }

            return originalValue;
        }
    });
}*/


/*const dc={fs, path, process, require};
// Apply createLoggingProxy to each member of dc
for (const key in dc) {
    if (dc.hasOwnProperty(key)) {
        dc[key] = createLoggingProxy(key, dc[key]);
    }
}
const ts=initTypescript(dc);
*/
//path.relative=(f,t)=>PathUtil.relPath(t,PathUtil.directorify(f));
export function compileProject(prj){
    return wrap(compileProjectF,"tsc running")(/*{ts,fs,path},*/ prj.path());
}
async function compileProjectF(/*{ts,fs,path},*/ projectPath/*:string*/) {
  // Read configuration from tsconfig.json
  process.chdir(projectPath);
  const configPath = ts.findConfigFile(projectPath, ts.sys.fileExists, 'tsconfig.json');
  if (!configPath) {
    throw new Error('Could not find tsconfig.json');
  }

  // Parse the configuration
  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);
  const parsedConfig = ts.parseJsonConfigFileContent(
    configFile.config, 
    ts.sys, 
    path.dirname(configPath)
  );
  console.log("conf",parsedConfig);
  const compilerHost = ts.createCompilerHost(parsedConfig.options);
  // Create the program
  const program = ts.createProgram(parsedConfig.fileNames, parsedConfig.options, compilerHost);

  // Compile
  const emitResult = program.emit();
  console.log("emitResult",emitResult);
  // Handle compilation errors
  const diagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
  if (diagnostics.length > 0) {
    const formatHost/*: ts.FormatDiagnosticsHost*/ = {
      getCanonicalFileName: path => path,
      getCurrentDirectory: ts.sys.getCurrentDirectory,
      getNewLine: () => ts.sys.newLine
    };

    const errorMessage = ts.formatDiagnosticsWithColorAndContext(diagnostics, formatHost);
    console.error(errorMessage);
    console.log(diagnostics);
    // Optionally throw an error if you want compilation to fail on any diagnostic
    if (emitResult.emitSkipped) {
      throw new Error('TypeScript compilation failed');
    }
  }

  console.log('Compilation successful!');
  return diagnostics;
}

