#!run
// @acepad/flex
//import { Index, Document } from "https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.1/dist/flexsearch.light.module.min.js";
import * as path from "path";
import {file,dir} from "@acepad/here";
import {ref} from "@hoge1e3/ref";

import {sleep} from "@hoge1e3/timeout";
import { Index, Document,IndexedDB } from "https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.2/dist/flexsearch.bundle.module.min.js";
//"https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.2/dist/flexsearch.compact.module.min.js";
let index, indexed=ref(false);

export async function initDb(d){
  d=file(d);
  index = new Document({
      document: {
        store:true,
          id: "id",
          index: [/*{
            field: "path",
            tokenize: "exact",
          },*/
          /*"timestamp",*/
          {
            field:"content",
            tokenize: "forward",
          }]
        ,
      }
  });
  await addAll(index,d);
  indexed.value=true;
  //search();

} 
function sortPath(paths, base) {
  if(!base)return paths;
  const baseDir = path.dirname(base);
  const i=paths.indexOf(base);
  if(i>=0)paths.splice(i,1);
  const inner=[];
  const outer=[];
  for(let path of paths){
    (path.startsWith(baseDir)?inner:outer).push(path);
  }
  //console.log("base",base,baseDir,inner);
  inner.sort((a,b)=>a.length-b.length);
  const so=base==baseDir? outer :sortPath(outer,baseDir);
  const res=[...inner,...so];
  res.unshift(base);
  return res;
}
//let w;
export async function main(q,curfile){
  curfile=file(curfile);
  const sh=this;
  let searching;
  let r=[];
  searching=true;
  await sleep(1);
  while(true){
    r=await index.search(q, { 
      index: "content",
      //enrich:true,
      merge:true,
    });
    searching=false;
    const res=refresh(q,r,curfile);
    if(indexed.value)return res;
    this.send(q,c,res);
    await sleep(1000);
  }
  function refresh(q,r,cf){
    let c=0;
    const ids=r.map(s=>s.id);
    const rs=cf?
      sortPath(ids,cf.path()):ids;
    return rs.map(s=>{
      const f=file(s);
      if(!f.exists())return ;
      if(f.isDir())return;
      if(c>50)return ;
      
      const lines=highlight(f,q);
      return {file:f.path(),lines};
    }).filter(s=>s);
  }
  function highlight(f, word) {
    const text=f.text();
    const lines = text.split('\n');
    const result = [];
    let ln=0;
    for (const line of lines) {
      if (line.includes(word)) {
        const parts = line.split(word);
        result.push({
          //file:f.path(),
          row:ln
        });
      }
      ln++;
    }
    return result;
  }
  return;
}
let c=0;
async function addAll(index,d){
  for(let f of d.recursive({excludes(f){
    return {".gsync":1,".sync":1,".git":1}.
    hasOwnProperty(f.truncSep());
  }})){
    //console.log("add",f.path());
    await add(index,f);
    c++;if(c%50==0)await sleep(1);
  }
}
async function add(index,f){
  const doc=await index.get(f.path());
  if(doc&&doc.timestamp===f.lastUpdate())return ;
  //console.log("upd",f.path(),doc);
    //await sleep(1);
  await index[doc?"update":"add"]({
    id:f.path(),
    timestamp: f.lastUpdate(),
    content: f.text()
  });
}
