#!run
// @acepad/flex
//import { Index, Document } from "https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.1/dist/flexsearch.light.module.min.js";
import * as path from "path";
import {file,dir} from "@acepad/here";
import {ref} from "@hoge1e3/ref";

import {sleep} from "@hoge1e3/timeout";
import { Index, Document,IndexedDB } from "https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.2/dist/flexsearch.bundle.module.min.js";
//"https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.2/dist/flexsearch.compact.module.min.js";
let index, indexed=ref(false);

export async function initDb(d){
  index = new Document({
      document: {
        store:true,
          id: "id",
          index: [/*{
            field: "path",
            tokenize: "exact",
          },*/
          /*"timestamp",*/
          {
            field:"content",
            tokenize: "forward",
          }]
        ,
      }
  });
  await addAll(index,d);
  indexed.value=true;
  //search();

} 
function sortPath(paths, base) {
  if(!base)return paths;
  const baseDir = path.dirname(base);
  const i=paths.indexOf(base);
  if(i>=0)paths.splice(i,1);
  const inner=[];
  const outer=[];
  for(let path of paths){
    (path.startsWith(baseDir)?inner:outer).push(path);
  }
  //console.log("base",base,baseDir,inner);
  inner.sort((a,b)=>a.length-b.length);
  const so=base==baseDir? outer :sortPath(outer,baseDir);
  const res=[...inner,...so];
  res.unshift(base);
  return res;
}
//let w;
export async function main(q,curfile){
  const sh=this;
  let searching;
  let r=[];
  async function search(){
    searching=true;
    await sleep(1);
    r=await index.search(q, { 
      index: "content",
      //enrich:true,
      merge:true,
    });
    searching=false;
    return refresh(q,r,curfile);
  }
  function refresh(q,r,cf){
    let c=0;
    const ids=r.map(s=>s.id);
    const rs=cf?
      sortPath(ids,cf.path()):ids;
    return rs.map(s=>{
        const f=file(s);
        if(!f.exists())return [];
        if(f.isDir())return [];
        if(c>50)return [];
        
        const lines=highlight(f,q);
        return lines;
      });
  }
  function highlight(f, word) {
    const text=f.text();
    const lines = text.split('\n');
    const result = [];
    let ln=1;
    for (const line of lines) {
      if (line.includes(word)) {
        const parts = line.split(word);
        const children = [];
  
        for (let i = 0; i < parts.length; i++) {
          children.push(parts[i]);
          if (i < parts.length - 1) {
            children.push(t.span({ class: "highlight" }, word));
          }
        }
        const lln=ln;
        result.push(t.div({
          onclick(){
            sh.edit(f,{row:lln,nomin:1,column:1});
          }
        },t.span({
          class: "filename"
        },`${f.name()}:${lln}`),...children));
      }
      ln++;
    }
    return result;
  }
  return;
}
async function addAll(index,d){
  for(let f of d.recursive({excludes(f){
    return f.truncSep()===".sync"||f.truncSep()===".git";
  }})){
    //console.log("add",f.path());
    await add(index,f);
  }
}
async function add(index,f){
  const doc=await index.get(f.path());
  if(doc&&doc.timestamp===f.lastUpdate())return ;
  //console.log("upd",f.path(),doc);
    await sleep(1);
  await index[doc?"update":"add"]({
    id:f.path(),
    timestamp: f.lastUpdate(),
    content: f.text()
  });
}
