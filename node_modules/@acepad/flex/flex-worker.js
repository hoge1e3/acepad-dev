#!run
// @acepad/flex
//import { Index, Document } from "https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.1/dist/flexsearch.light.module.min.js";
import * as path from "path";
import {file,dir} from "@acepad/here";
import {ref} from "@hoge1e3/ref";

import {sleep} from "@hoge1e3/timeout";
import { Index, Document,IndexedDB } from "https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.2/dist/flexsearch.bundle.module.min.js";
//"https://cdn.jsdelivr.net/gh/nextapps-de/flexsearch@0.8.2/dist/flexsearch.compact.module.min.js";
let index, indexed=ref(false);
let c=0;

export async function initDb(d){
  d=file(d);
  index = new Document({
      document: {
        store:true,
          id: "id",
          index: [/*{
            field: "path",
            tokenize: "exact",
          },*/
          /*"timestamp",*/
          {
            field:"content",
            tokenize: "forward",
          }]
        ,
      }
  });
  await addAll(d);
  indexed.value=true;
  //search();
  d.watch((t,f,m)=>{
    //if(f.isDir())return ;
    add(f);
    //console.log("watch",f.path());
  });
  async function addAll(d){
    for(let f of d.recursive({
      excludes(f){
        return {".gsync":1,".sync":1,".git":1}.
        hasOwnProperty(f.truncSep());
      },
      includeDir:true,
    })){
      await add(f);
      c++;if(c%50==0)await sleep(1);
    }
  }
  async function add(f){
    const doc=await index.get(f.path());
    if(doc&&doc.timestamp===f.lastUpdate())return ;
    await index[doc?"update":"add"]({
      id:f.path(),
      timestamp: f.lastUpdate(),
      content: text(f)
    });
  }

} 
function text(f){
  if(f.isDir()){
    return f.ls().join("\n");
  }else return f.text();
}
function sortPath(paths, base) {
  if(!base)return paths;
  const baseDir = path.dirname(base);
  const i=paths.indexOf(base);
  if(i>=0)paths.splice(i,1);
  const inner=[];
  const outer=[];
  for(let path of paths){
    (path.startsWith(baseDir)?inner:outer).push(path);
  }
  //console.log("base",base,baseDir,inner);
  inner.sort((a,b)=>a.length-b.length);
  const so=base==baseDir? outer :sortPath(outer,baseDir);
  const res=[...inner,...so];
  res.unshift(base);
  return res;
}
//let w;
export async function main(q,curfile){
  curfile=file(curfile);
  const sh=this;
  let searching;
  let r=[];
  searching=true;
  await sleep(1);
  while(true){
    r=await index.search(q, { 
      index: "content",
      //enrich:true,
      merge:true,
    });
    searching=false;
    const res=refresh(q,r,curfile);
    if(indexed.value)return res;
    this.send(q,res,c);
    await sleep(1000);
  }
  function refresh(q,r,cf){
    let c=0;
    const ids=r.map(s=>s.id);
    const rs=cf?
      sortPath(ids,cf.path()):ids;
    return rs.map(s=>{
      const f=file(s);
      if(!f.exists())return ;
      //if(f.isDir())return;
      if(c>50)return ;
      
      const lines=highlight(f,q);
      return lines && {file:f.path(),lines};
    }).filter(s=>s);
  }
  function highlight(f, word) {
    const t=text(f);
    const lines = t.split('\n');
    const result = [];
    let ln=0;
    for (const line of lines) {
      if (line.includes(word)) {
        const parts = line.split(word);
        result.push({
          //file:f.path(),
          row:ln
        });
      }
      ln++;
    }
    if(result.length==0)return null;
    return result;
  }
  return;
}
