import { asHash } from './types.js';
import { dateToPhpTimestamp, phpTimestampToDate, toBase64 } from './util.js';
export class PHPClientFactory {
    async init(serverUrl) {
        const api_key = Math.random().toString(36).slice(2);
        const res = await post(serverUrl, "create", { api_key });
        return new PHPClient(serverUrl, res.repo_id, api_key);
    }
    async load({ serverUrl, repoId, apiKey }) {
        return new PHPClient(serverUrl, repoId, apiKey);
    }
}
async function post(serverUrl, action, data) {
    const response = await fetch(`${serverUrl}?action=${action}`, {
        method: "POST",
        body: JSON.stringify(data),
    });
    if (response.status !== 200) {
        throw new Error(await response.text());
    }
    return await response.json();
}
export class PHPClient {
    serverUrl;
    repoId;
    apiKey;
    config;
    constructor(serverUrl, repoId, apiKey) {
        this.serverUrl = serverUrl;
        this.repoId = repoId;
        this.apiKey = apiKey;
        this.config = { serverUrl, repoId, apiKey };
    }
    toString() {
        return `[${this.serverUrl}: ${this.repoId}]`;
    }
    post(action, data) {
        return post(this.serverUrl, action, data);
    }
    /*async createRepository(): Promise<{ repo_id: string }> {
      const res = await this.post("create", { api_key: this.apiKey });
      this.repoId = res.repo_id;
      return res;
    }*/
    async addHead(branch, next) {
        const data = await this.post("set_head", {
            repo_id: this.repoId,
            branch,
            next,
            api_key: this.apiKey,
        });
        if (data.status === "ok") {
            return;
        }
        throw new Error(branch + " already exists. status=" + data.status);
    }
    async setHead(branch, current, next) {
        const data = await this.post("set_head", {
            repo_id: this.repoId,
            branch,
            current, next,
            api_key: this.apiKey,
        });
        if (data.status === "ok") {
            return;
        }
        throw new Error("Atomic change failed: Someone changed the head to " + data.status);
    }
    async hasHead(branch) {
        const res = await this.post("get_head", {
            repo_id: this.repoId,
            branch,
            allow_nonexistent: 1,
            api_key: this.apiKey,
        });
        return !!res.hash;
    }
    async getHead(branch) {
        const res = await this.post("get_head", {
            repo_id: this.repoId,
            branch,
            allow_nonexistent: 0,
            api_key: this.apiKey,
        });
        return asHash(res.hash);
    }
    async uploadObjects(objects) {
        const sObjects = objects.map((entry) => ({
            hash: entry.hash,
            content: toBase64(entry.content)
        }));
        const data = await this.post("upload", {
            repo_id: this.repoId,
            api_key: this.apiKey,
            objects: sObjects,
        });
        return phpTimestampToDate(data.timestamp);
    }
    async downloadSince(since) {
        const res = await this.post("download", {
            repo_id: this.repoId,
            api_key: this.apiKey,
            since: dateToPhpTimestamp(since),
        });
        const sObjects = res.objects;
        const objects = [];
        const newDownloadSince = phpTimestampToDate(res.newest);
        for (const { hash, content, mtime } of sObjects) {
            asHash(hash);
            const mtimed = mtime ? phpTimestampToDate(mtime) : new Date();
            objects.push({ hash, content: Buffer.from(content, 'base64'), mtime: mtimed });
        }
        return { objects, newest: newDownloadSince };
    }
    async downloadObjects(hashList) {
        const res = await this.post("download", {
            repo_id: this.repoId,
            api_key: this.apiKey,
            hash_list: hashList,
        });
        const sObjects = res.objects;
        const objects = [];
        for (const { hash, content, mtime } of sObjects) {
            asHash(hash);
            const mtimed = mtime ? phpTimestampToDate(mtime) : new Date();
            objects.push({ hash, content: Buffer.from(content, 'base64'), mtime: mtimed });
        }
        return objects;
    }
}
//# sourceMappingURL=webapi.js.map