import { asHash } from './types.js';
import { dateToPhpTimestamp, phpTimestampToDate, toBase64 } from './util.js';
export class PHPClient {
    serverUrl;
    repoId;
    apiKey;
    constructor(serverUrl, repoId, apiKey) {
        this.serverUrl = serverUrl;
        this.repoId = repoId;
        this.apiKey = apiKey;
    }
    async post(action, data) {
        const response = await fetch(`${this.serverUrl}?action=${action}`, {
            method: "POST",
            body: JSON.stringify(data),
        });
        if (response.status !== 200) {
            throw new Error(await response.text());
        }
        return await response.json();
    }
    async createRepository() {
        const res = await this.post("create", { api_key: this.apiKey });
        this.repoId = res.repo_id;
        return res;
    }
    async addHead(branch, next) {
        const data = await this.post("set_head", {
            repo_id: this.repoId,
            branch,
            next,
            api_key: this.apiKey,
        });
        if (data.status === "ok") {
            return;
        }
        throw new Error(branch + " already exists. status=" + data.status);
    }
    async setHead(branch, current, next) {
        const data = await this.post("set_head", {
            repo_id: this.repoId,
            branch,
            current, next,
            api_key: this.apiKey,
        });
        if (data.status === "ok") {
            return;
        }
        throw new Error("Atomic change failed: Someone changed the head to " + data.status);
    }
    async hasHead(branch) {
        const res = await this.post("get_head", {
            repo_id: this.repoId,
            branch,
            allow_nonexistent: 1,
            api_key: this.apiKey,
        });
        return !!res.hash;
    }
    async getHead(branch) {
        const res = await this.post("get_head", {
            repo_id: this.repoId,
            branch,
            allow_nonexistent: 0,
            api_key: this.apiKey,
        });
        return asHash(res.hash);
    }
    async uploadObjects(objects) {
        const sObjects = objects.map((entry) => ({
            hash: entry.hash,
            content: toBase64(entry.content)
        }));
        const data = await this.post("upload", {
            repo_id: this.repoId,
            api_key: this.apiKey,
            objects: sObjects,
        });
        return phpTimestampToDate(data.timestamp);
    }
    async downloadObjects(since) {
        const res = await this.post("download", {
            repo_id: this.repoId,
            api_key: this.apiKey,
            since: dateToPhpTimestamp(since),
        });
        const sObjects = res.objects;
        const objects = [];
        const newDownloadSince = phpTimestampToDate(res.newest);
        //const objectStore=this.objectStore;
        //let downloaded=0, skipped=0;
        for (const { hash, content, mtime } of sObjects) {
            asHash(hash);
            const mtimed = mtime ? phpTimestampToDate(mtime) : new Date();
            objects.push({ hash, content: Buffer.from(content, 'base64'), mtime: mtimed });
            /*downloaded++;
            if (await objectStore.has(hash)) {
                skipped++;
            } else {
                const binary = Buffer.from(content, 'base64');
                await objectStore.put(hash,  binary);
            }*/
        }
        return { objects, newest: newDownloadSince };
        //console.log(downloaded," objects downloaded. ",skipped," objects skipped.");
        //return newDownloadSince;
    }
}
//# sourceMappingURL=webapi.js.map