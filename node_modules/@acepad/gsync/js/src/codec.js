// compress.js
let loaded;
async function loadNodeLibs() {
    if (loaded)
        return loaded;
    const { createHash } = await import('node:crypto');
    const { createDeflate, createInflate } = await import('node:zlib');
    const { Readable } = await import('node:stream');
    const { Buffer } = await import('node:buffer');
    loaded = { createDeflate, createInflate, Readable, Buffer, createHash };
    return loaded;
}
export async function deflate(uint8array) {
    if (typeof CompressionStream !== 'undefined') {
        // --- ブラウザ環境 ---
        const stream = new Blob([uint8array])
            .stream()
            .pipeThrough(new CompressionStream('deflate'));
        const buffer = await new Response(stream).arrayBuffer();
        return new Uint8Array(buffer);
    }
    else {
        // --- Node.js 環境 ---
        const { createDeflate, Readable, Buffer } = await loadNodeLibs();
        const input = Buffer.from(uint8array);
        const chunks = [];
        await new Promise((resolve, reject) => {
            Readable.from([input])
                .pipe(createDeflate())
                .on('data', chunk => chunks.push(chunk))
                .on('end', resolve)
                .on('error', reject);
        });
        return Uint8Array.from(chunks);
    }
}
export async function inflate(uint8array) {
    if (typeof DecompressionStream !== 'undefined') {
        // --- ブラウザ環境 ---
        const stream = new Blob([uint8array])
            .stream()
            .pipeThrough(new DecompressionStream('deflate'));
        const buffer = await new Response(stream).arrayBuffer();
        return new Uint8Array(buffer);
    }
    else {
        // --- Node.js 環境 ---
        const { createInflate, Readable, Buffer } = await loadNodeLibs();
        const input = Buffer.from(uint8array);
        const chunks = [];
        await new Promise((resolve, reject) => {
            Readable.from([input])
                .pipe(createInflate())
                .on('data', chunk => chunks.push(chunk))
                .on('end', resolve)
                .on('error', reject);
        });
        return Uint8Array.from(chunks);
    }
}
export async function sha1Hex(input) {
    const buffer = input;
    if (typeof crypto !== 'undefined' && crypto.subtle) {
        // buffer.buffer refers raw buffer(when input is node Buffer), offset is not match. 
        const hashBuffer = await crypto.subtle.digest('SHA-1', buffer);
        return [...new Uint8Array(hashBuffer)]
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
    }
    else {
        const { createHash } = await loadNodeLibs();
        const hash = createHash('sha1').update(buffer).digest('hex');
        return hash;
    }
}
//# sourceMappingURL=codec.js.map