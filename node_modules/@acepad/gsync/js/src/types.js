const SymHash = Symbol("hash");
export function isHash(s) {
    return /^[0-9a-f]{40}$/.test(s);
}
export function asHash(s) {
    if (!isHash(s))
        throw new Error(`${s} is not a hash`);
    return s;
}
export function isMode(s) {
    return /^[0-9]+$/.test(s);
}
export function asMode(s) {
    if (!isMode(s))
        throw new Error(`${s} is not a mode`);
    return s;
}
const SymPathInRepo = Symbol("pathInRepo");
export function isPathInRepo(s) {
    return true;
}
const SymFilePath = Symbol("filePath");
export function isFilePath(s) {
    return true;
}
//export type Path=RelPath|AbsPath;
/*export function isPath(s:string): s is Path {
  return isAbsPath(s) || isRelPath(s);
}
export function asPath(s:string) {
  if (!isPath(s)) throw new Error(`${s} is not a path`);
  return s;
}*/
export function asFilePath(s) {
    if (!isFilePath(s))
        throw new Error(`${s} is not a file path`);
    return s;
}
export function asPathInRepo(s) {
    if (!isPathInRepo(s))
        throw new Error(`${s} is not a relative path in repository`);
    return s;
}
const SymFilename = Symbol("filename");
export function isFilename(s) {
    return true;
}
export function asFilename(s) {
    if (!isFilename(s))
        throw new Error(`${s} is not a filename`);
    return s;
}
const SymBranch = Symbol("branch");
export function isBranchName(s) {
    return true;
}
export function asBranchName(s) {
    if (!isBranchName(s))
        throw new Error(`${s} is not a branch name`);
    return s;
}
const SymRef = Symbol("ref");
export function isRef(s) {
    return !!s.match(/^refs\//);
}
export function asRef(s) {
    if (!isRef(s))
        throw new Error(`${s} is not a ref path`);
    return s;
}
export function asLocalRef(s) {
    return asRef(`refs/heads/${s}`);
}
export function isObjectType(type) {
    return ['commit', 'tree', 'blob', 'tag'].includes(type);
}
export class Author {
    name;
    email;
    date;
    constructor(name, email, date = new Date()) {
        this.name = name;
        this.email = email;
        this.date = date;
    }
    toString() {
        const timestamp = Math.floor(this.date.getTime() / 1000);
        const offsetMinutes = this.date.getTimezoneOffset();
        const absMinutes = Math.abs(offsetMinutes);
        const sign = offsetMinutes > 0 ? '-' : '+';
        const hh = String(Math.floor(absMinutes / 60)).padStart(2, '0');
        const mm = String(absMinutes % 60).padStart(2, '0');
        const tz = `${sign}${hh}${mm}`;
        return `${this.name} <${this.email}> ${timestamp} ${tz}`;
    }
    static parse(str) {
        const match = str.match(/^(.+?) <(.+?)> (\d+) ([+-]\d{4})$/);
        if (!match) {
            throw new Error(`Invalid author format: ${str}`);
        }
        const [, name, email, timestampStr, tz] = match;
        const timestamp = parseInt(timestampStr, 10);
        // タイムゾーンの補正は入れない（Gitはそのまま保存してる）
        const date = new Date(timestamp * 1000);
        return new Author(name, email, date);
    }
}
//# sourceMappingURL=types.js.map