import { Ignore } from 'ignore';
import { Author, Ref, CommitEntry, Conflict, GitObject, Hash, ObjectType, TreeDiffEntry, TreeEntry, BranchName, PathInRepo, FilePath } from './types.js';
import { ObjectEntry, ObjectStore } from './objects.js';
export declare class Repo {
    gitDir: FilePath;
    objectStore: ObjectStore;
    constructor(gitDir: FilePath, objectStore: ObjectStore);
    getObjectStore(): Promise<ObjectStore>;
    toFilePath(pathInRepo: PathInRepo): FilePath;
    toPathInRepo(filePath: FilePath): PathInRepo;
    readObject(hash: Hash): Promise<GitObject>;
    static objectEntryToGitObject(objval: ObjectEntry): Promise<GitObject>;
    writeObject(type: ObjectType, content: Uint8Array): Promise<Hash>;
    readBlobAsText(hash: Hash): Promise<string>;
    readTree(hash: Hash): Promise<TreeEntry[]>;
    static gitObjectToTree({ type, content }: GitObject): Promise<TreeEntry[]>;
    encodeTree(entries: TreeEntry[]): Buffer;
    writeTree(entries: TreeEntry[]): Promise<Hash>;
    buildTreeFromWorkingDir(): Promise<TreeEntry[]>;
    workingDir(): FilePath;
    inWorkingDir(_path: FilePath): boolean;
    readCommit(hash: Hash): Promise<CommitEntry>;
    static gitObjectToCommitEntry({ type, content }: GitObject): Promise<{
        tree: Hash;
        parents: Hash[];
        author: Author;
        committer: Author;
        message: string;
    }>;
    encodeCommit(entry: CommitEntry): Buffer;
    writeCommit(entry: CommitEntry): Promise<Hash>;
    readHead(ref: Ref): Promise<Hash | null>;
    traverseTree(entries: TreeEntry[], prefix?: PathInRepo): AsyncGenerator<{
        path: PathInRepo;
        hash: Hash;
        content?: Buffer;
    }>;
    updateHead(ref: Ref, hash: Hash): Promise<void>;
    findMergeBase(commitHashA: Hash, commitHashB: Hash): Promise<Hash>;
    diffTreeRecursive(oldTree: TreeEntry[], newTree: TreeEntry[], prefix?: PathInRepo): Promise<TreeDiffEntry[]>;
    threeWayMerge(baseTree: TreeEntry[], aTree: TreeEntry[], bTree: TreeEntry[]): Promise<{
        toA: TreeDiffEntry[];
        toB: TreeDiffEntry[];
        conflicts: Conflict[];
    }>;
    checkoutTreeToDir(treeHash: Hash, dirPath: FilePath): Promise<void>;
    getCurrentBranchName(): Promise<BranchName>;
    headPath(): string;
    setCurrentBranchName(branch: BranchName): Promise<void>;
    readMergeHead(): Promise<Hash | null>;
    writeMergeHead(commitHash?: Hash): Promise<void>;
    realGitRepoIsSubRepo(): boolean;
    isSubRepo(dir: FilePath): boolean;
    inSubRepo(_path: FilePath): boolean;
    applyDiff(diffs: TreeDiffEntry[]): Promise<void>;
    hasSymlinkInPath(targetPath: FilePath): Promise<boolean>;
}
export declare function writeFileIgnoreingCRLF(filePath: FilePath, content: Buffer): Promise<void>;
export declare class IgnoreChecker {
    repo: Repo;
    igs: Map<FilePath, RecursiveGitIgnore>;
    baseig: Ignore;
    constructor(repo: Repo);
    get(dir: FilePath): RecursiveGitIgnore;
    ignores(file: FilePath): boolean;
}
type IgnoreStack = {
    dir: FilePath;
    ig: Ignore;
};
export declare class RecursiveGitIgnore {
    stack: ReadonlyArray<IgnoreStack>;
    constructor(stack?: ReadonlyArray<IgnoreStack>);
    ignores(file: FilePath): boolean;
    pushed(dir: FilePath): RecursiveGitIgnore;
    poped(): RecursiveGitIgnore;
}
export declare function stripCR(content: Buffer<ArrayBufferLike>): Uint8Array<ArrayBufferLike>;
export declare function sameExceptCRLF(a: Buffer, b: Buffer): boolean;
export {};
