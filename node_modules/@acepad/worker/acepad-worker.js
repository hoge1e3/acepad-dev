// acepad-worker
import * as npm from "@acepad/npm";
import * as sw from "@hoge1e3/str2worker";
import * as cons from "./console.js";
import {sibling} from "@acepad/here";
export * as cons from "./console.js";
const em=(d)=>JSON.stringify(d);
async function createFixture(rpa){
    const deps=await npm.getDeps(rpa,true);
    deps.add(rpa);
    const data={};
    for(let pa of deps){
        pa=pa.up();
        for(let f of pa.recursive()){
            data[f.path()]=f.text();
        }
    }
    return data;
}
const cdn="https://cdn.jsdelivr.net/npm/";
const rpc=await import(cdn+"@hoge1e3/rpc@latest/dist/index.js");

function pNodeHeader(){
  return `${header()}
  (${hackTimeouts})();
  await pNode.boot();
  globalThis.pNode=pNode;
  const FS=pNode.getFS();
  await FS.mountAsync("/idb/","idb");
  if(process.env.POLICY_TOPDIR){
    FS.setDefaultPolicy({topDir:process.env.POLICY_TOPDIR});  
  }
`;

  function header(){
    let purl=process.env.PNODE_URL;
    // static import does not reports error
    // using relative path for import does not work in BlobURL?
    if (!purl /*||
        ( !purl.match(/^https:\/\//) &&
          !purl.includes("127.0.0.1") )*/
    ) purl=cdn+"petit-node@latest/dist/index.js";
    return `const pNode=await import(${em(purl)});`;
  }
}
function fixtureHeader(fixture){
  return `
function loadFixture(FS,fixture) {
  for (let name in fixture) {
      const f=FS.get(name);
      f.text(fixture[name]);
  }
}
const fixture=${em(fixture)};
loadFixture(fixture);
`; 
}
function rpcHeader(){
  const rurl=`${cdn}@hoge1e3/rpc@latest/dist/index.js`;
  return `const rpc=await import (${em(rurl)});
`;
}
function consoleHeader(){
  const consolePath=sibling(
    import.meta.url,"console.js").
    resolveLink().path();
  return `const cons=${importExpr(consolePath)};
  cons.client();
`;
}
function hackTimeouts(){
    for(let k of ["setTimeout","setInterval",
    "clearTimeout","clearInterval",]){
        globalThis[k]=globalThis[k].bind(globalThis);
    }
}
export function importExpr(f){
  if(typeof f.path==="function")f=f.path();
  return `await pNode.importModule(FS.get(${em(f)}))`;
}
export async function createProxy(main, rev={}){
    /*const rpa=npm.findPackageJson(f);
    const main=rpa.sibling(rpa.obj().main);*/
    const fixture={};//await createFixture(rpa);
    const ch_rev=Math.random()+"";
    const src=`
try{
  ${rpcHeader()}
  ${pNodeHeader()}
  Error.stackTraceLimit=100;
  const mod=${importExpr(main)};
  const srv={};
  const rev_cli=rpc.proxy.client(self, ${em(ch_rev)});
  for(let k in mod){
      let v=mod[k];
      if(typeof v==="function"){
          srv[k]=v.bind(rev_cli);
      }
  }
  rpc.proxy.server("default",[],srv);
  ${consoleHeader()}
}catch(e) {
  self.postMessage({stack:e.stack});
  console.error(e);
}
//# sourceURL=acepad-worker/${main.path()}
`;
    console.log("worker-gen",src);
    const w=sw.create(src);
    console.log("generated",w);
    w.addEventListener("message",(r)=>{
      if(r.data.stack){
        console.log("worker error",ch_rev,r.data.stack);
      }
    });
    cons.server(w);
    const revserv=rpc.proxy.server(w, ch_rev, [], rev);
    console.log("revserv",revserv);
    return rpc.proxy.client(w,"default");

    
}
export async function create(main){
    const src=`
${pNodeHeader()}
${consoleHeader()}
await pNode.importModule(FS.get(${em(main.path())}));
`;
    console.log(src);
    const w=sw.create(src);
    cons.server(w);
    return w;
    
}