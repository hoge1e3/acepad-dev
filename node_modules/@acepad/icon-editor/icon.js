// ===== Configuration =====
const ICON_SIZE = 32;                 // <- required constant icon size
const SCALE = 8;                     // visible zoom (32 * 16 = 512px canvas)

// ===== Elements =====
const view = document.getElementById('view');
const vctx = view.getContext('2d');
const hidden = document.createElement('canvas');
hidden.width = ICON_SIZE; hidden.height = ICON_SIZE;
const hctx = hidden.getContext('2d');
//Previews
const p1 = document.getElementById('p1');
const p2 = document.getElementById('p2');
const p4 = document.getElementById('p4');
const p1c = p1.getContext('2d');
const p2c = p2.getContext('2d');
const p4c = p4.getContext('2d');

// Disable smoothing everywhere for crisp pixels
[vctx, hctx, p1c, p2c, p4c].forEach(ctx => ctx.imageSmoothingEnabled = false);

// ===== State =====
let showGrid = true;
let tool = 'pen'; // 'pen' | 'eraser' | 'picker'
let drawing = false;
let currentColor = '#000000';

// ===== UI Wiring =====
const btn = id => document.getElementById(id);
const colorInput = document.getElementById('color');
colorInput.addEventListener('input', e => { currentColor = e.target.value; });

function setTool(next) {
  tool = next;
  ['pen','eraser','picker'].forEach(id => btn(id).setAttribute('aria-pressed', String(id===next)));
}
btn('pen').onclick = () => setTool('pen');
btn('eraser').onclick = () => setTool('eraser');
btn('picker').onclick = () => setTool('picker');

btn('toggleGrid').onclick = () => { showGrid = !showGrid; redraw(); };
btn('clear').onclick = () => { hctx.clearRect(0,0,ICON_SIZE,ICON_SIZE); redraw(); };
btn('fill').onclick = () => { hctx.clearRect(0,0,ICON_SIZE,ICON_SIZE); hctx.fillStyle = currentColor; hctx.fillRect(0,0,ICON_SIZE,ICON_SIZE); redraw(); };
btn('download').onclick = () => downloadPNG();

let curFile;
globalThis.load=load;
function load(file) {
  curFile=file;
  if (!file.exists()) {
    return;
  }
  const img = new Image();
  img.onload=()=>{
    hctx.clearRect(0,0,ICON_SIZE,ICON_SIZE);
    // draw with no smoothing
    hctx.imageSmoothingEnabled = false;
    // Use an offscreen canvas to draw source then scale into 32×32
    const off = document.createElement('canvas');
    off.width = img.width; off.height = img.height;
    const octx = off.getContext('2d');
    octx.drawImage(img, 0, 0);
    hctx.drawImage(off, 0, 0, off.width, off.height, 0, 0, ICON_SIZE, ICON_SIZE);
    redraw();
  };
  img.src=file.dataURL();
}
// Upload PNG -> fit to 32×32
document.getElementById('file').addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    hctx.clearRect(0,0,ICON_SIZE,ICON_SIZE);
    // draw with no smoothing
    hctx.imageSmoothingEnabled = false;
    // Use an offscreen canvas to draw source then scale into 32×32
    const off = document.createElement('canvas');
    off.width = img.width; off.height = img.height;
    const octx = off.getContext('2d');
    octx.drawImage(img, 0, 0);
    hctx.drawImage(off, 0, 0, off.width, off.height, 0, 0, ICON_SIZE, ICON_SIZE);
    redraw();
  };
  img.src = URL.createObjectURL(file);
  e.target.value = '';
});

// ===== Drawing helpers =====
function viewToPixel({clientX, clientY}) {
  const [cx,cy]=([clientX,clientY]);
  const s=window.pinchc.transform.scale;
  const rect = view.getBoundingClientRect();
  const x = Math.floor((cx - rect.left) / SCALE/s);
  const y = Math.floor((cy - rect.top) / SCALE/s);
  return {x, y};
}
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function setPixel(x, y, color) {
  if (x<0||y<0||x>=ICON_SIZE||y>=ICON_SIZE) return;
  if (color == null) {
    hctx.clearRect(x, y, 1, 1); // transparent
  } else {
    hctx.fillStyle = color;
    hctx.fillRect(x, y, 1, 1);
  }
}
function getPixel(x, y) {
  const d = hctx.getImageData(clamp(x,0,ICON_SIZE-1), clamp(y,0,ICON_SIZE-1), 1, 1).data;
  if (d[3]==0) return null;
  return `rgba(${d[0]},${d[1]},${d[2]},${(d[3]/255).toFixed(3)})`;
}

// ===== Mouse handling =====
let touchstartT;
let pickReserve;
const NOP=(()=>0);
let undo=NOP;
view.addEventListener('touchstart', e => {
  const t=e.touches[0];
  if(e.touches.length>1){
    undo();
    undo=NOP;
    drawing=false;
    return ;
  }

  drawing = true;
  const {x,y} = viewToPixel(t);
  pickReserve = getPixel(x,y);
  touchstartT=setTimeout(()=>{
    if(pickReserve==null){
      setTool("eraser");
      setPixel(x,y,null);
    }else{
      setTool("pen");
      setPixel(x,y,pickReserve);
      currentColor = rgbaToHex(pickReserve);
    }
    colorInput.value = currentColor;
    redraw();
  },500);
  undo=()=>{
    setPixel(x,y,rgbaToHex(pickReserve));
    redraw();
  };

  if (e.altKey || tool === 'picker') {
    const p=getPixel(x,y);
    if (p==null) {
      setTool("eraser");
    } else {
      setTool("pen");
      currentColor = rgbaToHex(p);
      colorInput.value = currentColor; 
    }
  } else if (e.button === 2 || tool === 'eraser') {
    setPixel(x,y,null);
  } else {
    setPixel(x,y,currentColor);
  }
  redraw();
});
window.addEventListener('touchend', (e) => { 
  const t=e.touches[0];
  drawing = false; 
  clearTimeout(touchstartT);
  //const {x,y} = viewToPixel(t);
  penWidth=1;

});
let penWidth=1;
function setPixelBold(x,y,c,w) {
  w=Math.floor(w);
  let s=Math.floor(w/2);
  for (let j=-s;j<-s+w;j++) {
    for (let i=-s;i<-s+w;i++) {
      setPixel(x+j,y+i,c);
    }
  }
}
view.addEventListener('touchmove', e => {
  clearTimeout(touchstartT);
  const t=e.touches[0];
  if (!drawing) return;
  
  const {x,y} = viewToPixel(t);
  if (e.altKey || tool === 'picker') {
    currentColor = rgbaToHex(getPixel(x,y));
    colorInput.value = currentColor;
  } else if (e.buttons === 2 || tool === 'eraser') {
    setPixelBold(x,y,null,penWidth);
  } else {
    setPixelBold(x,y,currentColor,penWidth);
  }
  penWidth+=0.01;
  redraw();
  e.preventDefault();
});

function rgbaToHex(rgba) {
  if (rgba==null) return null;
  // Expect rgba(r,g,b,a)
  const m = rgba.match(/rgba?\((\d+),(\d+),(\d+)/);
  if (!m) return currentColor;
  const r = (+m[1]).toString(16).padStart(2,'0');
  const g = (+m[2]).toString(16).padStart(2,'0');
  const b = (+m[3]).toString(16).padStart(2,'0');
  return `#${r}${g}${b}`;
}

// ===== Render =====
function drawChecker(ctx, w, h, cell = SCALE/2) {
  ctx.save();
  for (let y=0; y<h; y+=cell) {
    for (let x=0; x<w; x+=cell) {
      const odd = ((x/cell) + (y/cell)) & 1;
      ctx.fillStyle = odd ? '#9aa0a6' : '#cfd3d6';
      ctx.fillRect(x,y,cell,cell);
    }
  }
  ctx.restore();
}

function drawGrid(ctx, size, scale) {
  ctx.save();
  ctx.beginPath();
  for (let i=0;i<=size;i++) {
    ctx.moveTo(0.5 + i*scale, 0);
    ctx.lineTo(0.5 + i*scale, size*scale);
    ctx.moveTo(0, 0.5 + i*scale);
    ctx.lineTo(size*scale, 0.5 + i*scale);
  }
  ctx.strokeStyle = 'rgba(0,0,0,.25)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

function redraw() {
  // Large view (checkerboard + scaled artwork)
  drawChecker(vctx, view.width, view.height, SCALE/2);
  vctx.drawImage(hidden, 0, 0, ICON_SIZE, ICON_SIZE, 0, 0, ICON_SIZE*SCALE, ICON_SIZE*SCALE);
  if (showGrid) drawGrid(vctx, ICON_SIZE, SCALE);
  // Previews
  [p1c,p2c,p4c].forEach((ctx, i) => {
    const mul = [1,2,4][i];
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,ICON_SIZE*mul,ICON_SIZE*mul);
    ctx.drawImage(hidden, 0,0,ICON_SIZE,ICON_SIZE, 0,0,ICON_SIZE*mul,ICON_SIZE*mul);
  });
}

function downloadPNG() {
  if (curFile) {
    curFile.dataURL(hidden.toDataURL('image/png'));
    alert("Saved to "+curFile);
    return;
  }
  const link = document.createElement('a');
  link.download = 'icon-32x32.png';
  link.href = hidden.toDataURL('image/png');
  document.body.appendChild(link);
  link.click();
  link.remove();
}

// ===== Swatches =====
const preset = ['#000000','#ffffff','#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff','#808080','#c0c0c0','#ffa500','#8b4513'];
const swatches = document.getElementById('swatches');
preset.forEach(c => {
  const el = document.createElement('button');
  el.className = 'swatch'; el.title = c; el.style.background = c; el.onclick = () => { currentColor = c; colorInput.value = c; };
  swatches.appendChild(el);
});

// Initialize the main view size from constants
view.width = ICON_SIZE * SCALE;
view.height = ICON_SIZE * SCALE;

// First paint
redraw();


/*
view.addEventListener('contextmenu', e => e.preventDefault());
view.addEventListener('mousedown', e => {
  drawing = true;
  const {x,y} = viewToPixel(e);
  if (e.altKey || tool === 'picker') {
    currentColor = rgbaToHex(getPixel(x,y));
    colorInput.value = currentColor;
  } else if (e.button === 2 || tool === 'eraser') {
    setPixel(x,y,null);
  } else {
    setPixel(x,y,currentColor);
  }
  redraw();
});
window.addEventListener('mouseup', () => { drawing = false; });
view.addEventListener('mousemove', e => {
  if (!drawing) return;
  const {x,y} = viewToPixel(e);
  if (e.altKey || tool === 'picker') {
    currentColor = rgbaToHex(getPixel(x,y));
    colorInput.value = currentColor;
  } else if (e.buttons === 2 || tool === 'eraser') {
    setPixel(x,y,null);
  } else {
    setPixel(x,y,currentColor);
  }
  redraw();
  e.preventDefault();
});
*/
