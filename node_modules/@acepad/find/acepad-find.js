//!run
import {match} from "textmatcher";
import bottomup from "@hoge1e3/bottomup";
import {initMarker, findWord} from "./marker.js";
import {sessionInfo, createSession} from "@acepad/sessions";
import {locate,currentLine,print} from "@acepad/cursor";
const sleep=(t)=>new Promise(s=>setTimeout(s,t));
export function byts(a,b){
    return b.lastUpdate()-a.lastUpdate();
}
export function run(sh){
    let acepad=sh.$acepad;
    let editor=acepad.getMainEditor();
    initMarker(editor);
    let dir;
    let i=sessionInfo(editor.session);
    if(i.file){
        dir=i.file;
        if(!dir.isDir())dir=dir.up();
    }else{
        dir=sh.getcwd();
    }
    let t=editor.getSelectedText()||"";
    let s=createFind(sh,t,dir);
    editor.setSession(s);
}
export function createFind(sh,w="",dir="."){
    let acepad=sh.$acepad;
    /*const {
        locate,currentLine,print,
    }=acepad;*/
    const editor=acepad.getMainEditor();
    let session;
    //console.log("fnd",acepad);
    function top(){
        let s=editor.session.getSelection();
        s.moveCursorFileStart();
        s.clearSelection();
    }
    function bot(){
        let s=editor.session.getSelection();
        s.moveCursorFileEnd();
        s.clearSelection();
    }
    function onActivated(editor){
        //bot();
        locate(editor, -1);
    }
    async function runf(word,editor){
        //editor.setValue("find: "+word+"\n");
        locate(editor, -1);
        session.setValue(initext(word)+"Searching...\n");
        await sleep(0);
        sessionInfo(session,{
            name:"?"+word
        });
        //print("\n");
        //bot();
        window.findWord=word;
        findWord(word);

        const files=[];
        const fil=(typeof word==="string"?
        (line)=>line.indexOf(word)>=0:
        (line)=>word.exec(line)
        );
        //dir.recursive((f)=>files.push(f));
        const home=sh.resolve(sh.$home).resolveLink();
        for (let f of bottomup(dir,{
            excludes(f){
                //console.log(f, f.startsWith(".git"));
                if (f.truncSep()===".git"||f.truncSep()===".gsync") {
                    return true;
                }
                /*if (f.path().includes(".git/")) {
                    throw new Error("Found .git in path: " + f.path());
                }*/
                return false;
            }
        })) {
            if(!home.contains(f.resolveLink()))break;
            let ln=1;
            //editor.onTextInput("{");
            if(fil(f.path())) {
                pbot(`${f.relPath(dir)}(1): (Filename match)\n`);
            }
            for(let line of f.text().split("\n")){
                if(fil(line)){
                     pbot(`${f.relPath(dir)}(${ln}): ${line}\n`);   
                }
                ln++;
            }
            await sleep(0);
            //editor.onTextInput("}");
        }
        pbot("Done\n");
        function pbot(s){
            locate.save(session,()=>{
                locate.bottom(session);
                print(session,s);
            });
        }
        //top();
    }
    //SYM
    delete window.findWord;
    session= createSession({
        type:"find",
        text:initext(w),
        name:"?"+w,
        onActivated,
        commands:{
            return(){
                onEnter({
                    line:currentLine(session)
                });
            }
        },
        //onEnter
    });
    function initext(w){
        return "find: "+w+
        "\nsymb: "+w+
        "\nregx: "+w+
        "\ndir: "+dir+
        "\n";
    }
    return session;
    function onEnter(e){
        match(session.getValue(), 
        /\ndir: *([^\n]+)/, (m)=>{dir=sh.resolve(m[1]);});
        match(e.line,
            /^find: *(.*)/,
            (m)=>{
                runf(m[1],editor);
            },
            /^symb: *([\w\d]+)/,
            (m)=>{
                runf(new RegExp("\\b"+m[1]+"\\b"),
                editor);
            },
            /^regx: *(.*)/,
            (m)=>{
                runf(new RegExp(m[1]),editor);
            },
            /^(.*)\((\d+)\):/,
            (m)=>{
                sh.edit(dir.rel(m[1]),{
                    row:m[2]-0,column:0
                });
            },
        );
    }
}

