import MutablePromise from "mutable-promise";
import {convertStack} from "@acepad/os";
import {file} from "@acepad/here";
import {setMode} from "@acepad/mode-shell";

export function trial(f){
    if(typeof f!=="function")return trial(()=>f);
    return (async(...args)=>{
        try{
            await f(...args);
        }catch(e){
             window.onerror(e);       
        }
    });
}
function stripPrompt(line){
    return line.replace(/^.*[:\$%]\s*/,"");
}

//export let dses;
export function debugSession(sh, cmd){
    const {
        events,
        setConfig,findWord,
        exec,unsetSel,attachCommands,detachCommands,
        setModifier,renderModifierState,
        locate,currentLine,print,goLineEnd,
        sessionInfo,createSession,changeSession,
        findSession,findSessions,
        showMenuButton,showMenuButtons,
    }=sh.$acepad;
    sh.setout({
        log(...a){
            dprint(...a);    
        }
    });
    let sch;
    function dprint(...a){
        //console.log("dprint",...a);
        if(!sch){
          changeSession(dses);
          sch=true;
        }
        print(dses,...a);
    }
    let dses=createSession({
        type:"debug",
        commands:{
            return(editor){
                onEnter({
                    editor,
                    line:currentLine()
                });
            },
        },
    });
    setMode(dses,{
        sh,
        getContext(editor,session,pos,prefix){
            const line=session.getLine(pos.row);
            let picked=stripPrompt(line);
            let c=pos.column-(line.length-picked.length);
            let secondArg=picked.substring(0, c-prefix.length).match(/\s$/);
            if(secondArg)return "file";
            else return "command";
        }
    });
    let inpmode;
    sh.input=function (prompt="? "){
        this.echo(prompt,{n:1});
        inpmode=new MutablePromise();
        return inpmode.then((r)=>{
            const p=prompt.trim();
            if (r.startsWith(p)) r=r.substring(p.length).trim();
            return r;
        });
    };
    if (window.ace_language_tools) {
        let completers=[window.ace_language_tools.textCompleter];
        dses.setOptions({enableLiveAutocompletion:completers});
        //console.log("comp",completers);
    }
    function looksLikeShell(cmd) {
        let res;
        //let head={var:1,let:1,const:1, function:1};
        cmd.replace(/^\s*(\S+)(\s.*)?$/,(_,c,a)=>{
            //console.log("{"+c+"}");
            if(sh.hasCmd(c)){
                res=c+(a||"");
            }
        });
        console.log("lls",cmd,res);
        if(res)return res;
        /* cmd.replace(/^\[(.*)\]\$\s*(.*)/,(_,d,c)=>{
            sh.cd(d);
            res=c;
        });*/
        return res;
    }
    async function onEnter(e){
        const editor=e.editor;
        goLineEnd();
        dprint("\n");
        if(inpmode){
            inpmode.resolve(e.line);
            inpmode=null;
            return ;
        }
        return procLine(e.line);
    }
    async function procLine(line){
        let issh;
        try{
            let r;
            issh=looksLikeShell(line);
            let f=hasTrace(line);
            if(f){
                sh.edit(f.file,f);
                return ;
            }else if (issh) {
                addCommandHist(line);
                r=await sh.enterCommand(issh);   
            } else {
                addCommandHist(line);
                r=await eval(line);
            }
            window.ans=r;
            if(r!=null)dprint(r);
            console.log(r);
            if(sch)dprint("\n");
        }catch(ex){
            //dprint(ex.message+"\n");
            dprint(convertStack(ex));
            console.error(ex);
            dprint("\n");
        }finally{
            if(issh){
                sh.prompt();
            }
        }
    }
    function cls(){
        dses.setValue("");
        hist();
    }
    sh.cls=cls;
    sh.$session=dses;
    if(!cmd){
        hist();
    }else if(typeof cmd==="string"){
        procLine(cmd);
    }else{
      sh.evalCommand(cmd);
    }
    function hist(){
        for(let k in commandHist){
            dprint(k+"\n");
        }
    }
    return dses;
}
export var commandHist={};
try{
    commandHist=JSON.parse(
        localStorage.commandHist)||{};
}catch(e){
}
export function addCommandHist(c){
    commandHist[c]=new Date().getTime();
    let s=Object.values(commandHist).sort().reverse();
    let th=s[16]||0;
    for(let k in commandHist){
        if(commandHist[k]<th)delete commandHist[k];
    }
    localStorage.commandHist=
    JSON.stringify(commandHist);
}
export function hasTrace(line){
    let res;
    //const home=getHome();
            console.log("hasTrace",line);
    line.replace(
        /(\/.+):(\d+):(\d+)/,
        (_,f,r,c)=>{
            console.log("hasTrace",f,r,c);
            f=f.replace(/^\/+/,"/");
            f=file(f);
            if(!f.exists()){
                return ;
            }
            res={
                file:f,
                row:r-0,
                column:c-0,
            };
        });
    return res;
}
