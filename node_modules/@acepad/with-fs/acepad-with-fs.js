// acepad-with-fs
import {open} from "@acepad/browser";
import {trial,debugSession} from "@acepad/debug";
import {initVConsole,showVConsole} from "show-vconsole";
import {run} from "@acepad/find";
//import * as flex from "@acepad/flex";
import unload from "@hoge1e3/unload";
import {openFile,createSessionListWithRecents} from "@acepad/files";
import {init} from "acepad";
import * as fkeys from "@acepad/function-keys";
import {loadScriptTag} from "@hoge1e3/loadScript";
import {gen,fix} from "@acepad/genai";
import * as hg from "@acepad/hourglass"; 
import * as dombind from "@hoge1e3/dom-bind";
import * as local from "ace-local-commands";
import * as command from "@acepad/command-parser";
import {sessionInfo,initSessions,extend} from "@acepad/sessions";
import * as _dummy from "./acepad-cmd.js";
import * as flex from "@acepad/flex";
import {getValue,assign} from "pnode-bootloader";
/*global $*/
const cdn="https://cdn.jsdelivr.net/npm/";
function r(u){
  return u.startsWith("https://")?u:`${cdn}${u}`;
}
async function loadScripts(scripts) {
    return Promise.all(scripts.
    map(r).
    map(async (u)=>{
        try{
            //console.log("Loading ",u);
            await loadScriptTag(u);
            //console.log("Loaded ",u);
        }catch(e){
            alert("load fail"+e.message);
        }
    }));
}
const prefetchScript=getValue("prefetchScript") || loadScriptTag;
function prefetch(){
    const to_p=(u)=>
    typeof u==="string" ? 
    prefetchScript(cdn+u) : u;
    const para=(...a)=>Promise.all(a.map(to_p));
    const seq=async (...a)=>{
        for (let u of a) await to_p(u);
    };
    return para(
    "jquery@1.12.1/dist/jquery.min.js",
    "vconsole@latest/dist/vconsole.min.js",
    seq(
    "ace-builds@1.39.0/src-noconflict/ace.js",
    "ace-builds@1.39.0/src-noconflict/ext-language_tools.js"
    ));
}
async function autoexec(){
  this["acepad-cmd"]("flexsearch",{k:"F3"});
  this["acepad-cmd"]("newcmd",{k:"F2"});
  this["acepad-cmd"]("runMenu",{k:"F5"});
  this["acepad-cmd"]("filetree",{k:"F8"});
  this.pinch();
}
export async function main(){
    const sh=this;
    const dirn=sh.resolve(
        import.meta.url
    ).up();
    if (sh.$home){
        const dir_nodem=sh.resolve(sh.$home).rel("node_modules/");
        setPath(sh,dir_nodem);    
        flex.init(sh);
    }
    await prefetch();
    const openf=await submenu(sh);
    console.log("Render HTML", openf);
    // vConsole may be inited in bootloader.
    // <style>s for vConsole are added in <head>, so do not erase them!
    // DOM element for vConsole itself is outer <body>, so it is safe removing all content in <body>
    document.body.innerHTML="";
    await open(dirn.rel("ace.html"),{keep:true});
    await this.sleep(0.01);
    hg.main();
    /*const {setForce}=unload({
        oncancel(){
           setTimeout(()=> 
          document.documentElement.requestFullscreen().then(
              ()=>document.exitFullscreen())
        ,100);  
        }
    });*/
    const acepad=window.acepad=await init(document.querySelector("#acepad"));  
    const editor=acepad.getMainEditor(); 
    extend(acepad);
    initSessions(editor);
    console.log("Render Done");
    await this.sleep(0.01);
    editor.setFontSize((process.env.FONT_SIZE||16)-0);
    sh.$acepad=acepad;
    sh.setenv("ROOT_SHELL",sh);
    assign({acepad,sh});

    dombind.bind(document.querySelector("#acepad"),acepad);
    //sh.setenv("ACEPAD_INSTANCE",acepad);
    
    //let {openFile}=await sh.jsm("acepad-files");
    local.addGlobalCommands(editor,command.parse({
        F1:"recentFiles",
        F7:"dirup",
        F11:"showConsole",
        F12:"reloadPage",
        "ctrl-g":"toggleGutter",
        "ctrl-9":"toggleFullScreen",
        "ctrl-f":"findFiles",//ok use flexsearch
        reloadPage(){location.reload();},
        findFiles(){flex.main.call(sh);},
        dirup:()=>{
            let si=sessionInfo(
                acepad.getMainEditor().session);
            if(si.file){
                openFile(sh, si.file.up());
            }
        },
        showConsole:()=>{
            showVConsole();
        },
        toggleGutter:()=>{
            //autogutt disable this
            const editor=acepad.getCurrentEditor();
            //console.log("gutt",editor.renderer.getShowGutter());
            editor.renderer.setShowGutter(
                !editor.renderer.getShowGutter());
        },
        toggleFullScreen() {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        },
        recentFiles(){
            editor.setSession(recents); 
        },
        runMenu(){
            sh.runMenu();
        },
        genAi(){
            gen(sh);
        },
        fixAi(){
            fix(sh);
        },
    }));

    setTimeout(initVConsole,1000);
    sh.debugSession=()=>debugSession(sh);
    autogutt(acepad);
    fkeys.show(acepad);
    const recents=createSessionListWithRecents(sh);
    if (openf) {
      openFile(sh, openf);
    } else {
      editor.setSession(recents);
    }
    if (process.env.SUBMENU_SELECTED) {
      try {
        const f=sh.resolve(process.env.SUBMENU_SELECTED);
        if (f.exists()) openFile(sh, f);
      } catch(e) {
        console.error(e);
      }
    }
    sh.keysel(1);
    sh.quota();
    hackTimeouts();
    try{
      await autoexec.call(this);
    }catch(e){
      console.error(e);
    }
  /*this.exec("acepad-cmd -k=F2 newcmd");
    this.exec("acepad-cmd -k=F3 flexsearch");*/
    return acepad;
}
function setPath(sh,nodem){
    sh.addPath(nodem.rel(".bin/").path());
    sh.addPath(sh.resolve("bin/").path());
    sh.addPath(sh.resolve("sbin/").path());
}
let prevs;
function autogutt(acepad){
  let guide;
  const style=acepad.editor.container.style;
  function createGuide(e){
    return {
      startTime: performance.now(),
      startPoint: [r.getScrollLeft(), r.getScrollTop()],
      swipeState: null,
      touchend(e) {
        const endp=[r.getScrollLeft(), r.getScrollTop()];
        const elapsed=performance.now()-this.startTime;
        //console.log("elapsed",elapsed);
        if (elapsed<300) {
          this.swipeState={p:endp, startTime:performance.now()};
          this.activated=true;
        }
      },
      activated:false,
      interval() {
        if (!this.activated) return;
        //console.log("x",this.startPoint[0]);
        r.scrollToX(this.startPoint[0]);
        const p=[r.getScrollLeft(), r.getScrollTop()];
        if (performance.now()-this.swipeState.startTime>300 && 
          Math.abs(this.swipeState.p[1]-p[1])<1) {
          //console.log("deact", this.swipeState, p);
          this.activated=false;
        } else {
          try {
            //console.log("el-y",performance.now()-this.swipeState.startTime, 
            //Math.abs(this.swipeState.p[1]-p[1]));
          }catch(e){
            console.error(e);
            this.activated=false;
          }
        }
        this.swipeState.p=p;
      },
    };
  }
  const r=acepad.getMainEditor().renderer;
  const c=r.container;
  c.addEventListener("touchstart",(e)=>{
    guide=createGuide(e);
  });
  c.addEventListener("touchend",()=>{
    if (guide) guide.touchend();
  });
  setInterval(()=>{
    const p=[r.getScrollLeft(), r.getScrollTop()];
    if (p[0]>50) {
      style.left=`-${p[0]-50}px`;
      //r.setShowGutter(false);
    } else {
      style.left=`0px`;
      //r.setShowGutter(true);
    }
    if (guide) guide.interval();
  },10);
}
function hackTimeouts(){
    for(let k of ["setTimeout","setInterval",
    "clearTimeout","clearInterval",]){
        globalThis[k]=globalThis[k].bind(globalThis);
    }
}
async function submenu(sh){
  const getSelectedSubmenu=getValue("getSelectedSubmenu");
  if (!getSelectedSubmenu) return;
  const s=getSelectedSubmenu();
  if (!s) return;
  const p=await s;
  const f=sh.resolve(p);
  if (f.exists()) return f;//openFile(sh, f);
}

