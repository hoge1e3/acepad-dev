// docker-terminal
//!run
/*global Terminal, FitAddon, $*/
//use pty.resize on server to resize
import {showWidget,showIframe} from "@acepad/widget";
import {KeyPicker} from "@acepad/keypicker";
const timeout=(t)=>new Promise(s=>setTimeout(s,t));
import {modeMap} from "@acepad/files";
import {loadScriptTag} from "@hoge1e3/loadScript";

const xterm="https://unpkg.com/@xterm/xterm";
const xterm_af="https://unpkg.com/@xterm/addon-fit";
async function load(){
    if(typeof Terminal!=="undefined")return;
    $(`<link rel="stylesheet" href="${xterm}/css/xterm.css"/>`).appendTo("body");
    await loadScriptTag(`${xterm}/lib/xterm.js`);
    await loadScriptTag(`${xterm_af}/lib/addon-fit.js`);
    
}
export async function create({
    pass,ws,acepad,init,noalert
}){
    acepad.setModifier("edit",0);
    acepad.renderModifierState();
    await load();
    let wid=showWidget($("<div>"));
    var term = new Terminal();
    globalThis.term=term;
    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    const telem=$("<div>").css({
        position:"absolute",left:0,top:0,
        width:"100%",height:"90%"
    }).appendTo(wid.element);
    
    const css_bot={
        position:"absolute",left:0,bottom:0,
        width:"100%",height:"10%"
    };
    const btns=$("<div>").css(css_bot).appendTo(wid.element);

    $("<button>").text("paste").click(async()=>{
        const c= await navigator.clipboard.readText();
        w.send(c);
    }).appendTo(btns).css({padding:"5px",background:"cyan"});
    $("<button>").text("esc").click(async()=>{
        w.send("\x1b");
    }).appendTo(btns).css({padding:"5px",background:"lime"});
    
    term.open(telem[0]);
    fitAddon.fit();
    console.log("term size=",term.rows, term.cols);
    const w=new WebSocket(ws);
    globalThis.term_ws=w;

    w.addEventListener("open",(e)=>{
        acepad.setCurrentEditor(editor);
        term.textarea.setAttribute("readonly",true);
        term.focus();
        console.log("pass",pass);
        w.send(pass+"\r\n");
        //if(init)setTimeout(()=>w.send(init),500);
    });
    let buf="";
    w.addEventListener("message",(e)=>{
        e.data.text().then((s)=>{
            if (typeof buf==="string"){
                buf+=s;
                if (buf.match(/Welcome/)) {
                    buf=null;
                    console.log("Welcome received!");
                    w.send(`RSZ${term.cols}x${term.rows}`);
                    if(init)w.send(init);
                }
            }
            term.write(s);  
        });
    });
    if(!noalert){
        w.addEventListener("close",(e)=>{
            alert("closed");
        });
    }
    term.onKey(({key})=>{
        console.log("ky",key);
        w.send(key);
    });
    wid.on("close",()=>w.close());
    
    const editor=KeyPicker();//a.edit(d[0]);
    //console.log("ed",editor);
    wid.on("show",()=>{
        acepad.setCurrentEditor(editor);
    });
    editor.events.on("input",({text})=>{
        w.send(text);
    });
    editor.events.on("command",({modifier,keyCode})=>{
        //d.text(modifier+" "+keyCode);
        if(keyCode>=37&&keyCode<=40){
            const c="\x1bO"+"DACB"[keyCode-37];//.charCodeAt(0)-96;
            //console.log("code",keyCode,c);
            w.send(c);
        }else if(keyCode===13){
            w.send("\n");
        }else if(modifier===1&&keyCode==50){
            w.send(String.fromCharCode(27));
        }else if(modifier===1&&keyCode>=65){
            w.send(String.fromCharCode(keyCode-64));
        }else{
            w.send(String.fromCharCode(keyCode));
        }
    });
    const instance={
        widget:wid,
        webSocket:w,
        terminal:term,
        addJsonHandler,
    };
    term.parser.registerOscHandler(10,(data)=>{
        try{
            const r=procJson({
                data:JSON.parse(data),
                ...instance,
            });
            if(!r)console.warn("not proc",data);
        }catch(e){
            console.log("errd",data);
            console.error(e);
        }
    });
    /*await timeout(1000);
    acepad.setCurrentEditor(editor);
    term.textarea.setAttribute("readonly",true);
    term.focus();
    w.send(pass+"\n");*/
    const jsonHandlers=[];
    function addJsonHandler(func){
        jsonHandlers.push(func);
    }
    function procJson(e/*{widget,data,webSocket}*/){
        return jsonHandlers.some((h)=>h(e));
    }
    return instance;
}
/*
print("\x1b[D") # 左に1文字移動b
print("\x1b[A") # 上に1行移動p
print("\x1b[C") # 右に1文字移動 f
print("\x1b[B") # 下に1行移動n

input on terminal:
cd /app/ws/ ; python3 raw.py node raw_worker.js

input on browser console:
term_ws.send(JSON.stringify({x:3,y:10})+"\r")
term_ws.send(JSON.stringify({x:3,y:10,cmd:"quit"})+"\r")
*/
